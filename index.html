<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess Defense: Ranking</title>
    <style>
        /* ëª¨ë°”ì¼ ê¸°ë³¸ ì„¤ì • */
        body {
            background-color: #121212;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* ìƒë‹¨ HUD */
        #top-hud {
            height: 50px;
            background: #1e1e1e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .hud-item {
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .energy-count { color: #ffd700; font-size: 20px; }
        .score-display { color: #fff; font-size: 14px; margin-left: 10px; }
        .wave-text { color: #00e5ff; font-size: 16px; margin-left: 5px; text-shadow: 0 0 5px #00e5ff;}
        .progress-bar-bg { width: 60px; height: 8px; background: #333; border-radius: 4px; overflow: hidden; margin-left: 10px; }
        .progress-bar-fill { height: 100%; background: #ff4444; width: 0%; transition: width 0.3s; }

        /* ê²Œì„ ìº”ë²„ìŠ¤ ì˜ì—­ */
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2a2a2a;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 900/500;
        }

        /* ğŸƒ ì¹´ë“œ ì„ íƒ ì˜¤ë²„ë ˆì´ */
        #card-selection {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 60;
        }
        
        #card-selection h2 { color: #ffd700; margin-bottom: 15px; font-size: 6vw; text-shadow: 0 0 10px #ffd700; }
        #card-selection p { font-size: 3.5vw; color: #ccc; margin-bottom: 15px; }

        .cards-container {
            display: flex;
            justify-content: center;
            gap: 2%;
            width: 95%;
            height: 60%;
        }

        .card {
            background: linear-gradient(145deg, #2a2a2a, #333);
            border: 2px solid #555;
            border-radius: 12px;
            width: 31%;
            height: 100%;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            box-sizing: border-box;
        }

        .card:active { transform: scale(0.95); border-color: #ffd700; background: #3a3a3a; }
        
        .card-icon { font-size: 8vw; margin-bottom: 5px; margin-top: 10px;}
        .card-title { font-weight: bold; color: #fff; margin-bottom: 5px; font-size: 3.5vw; white-space: nowrap;}
        .card-desc { font-size: 2.8vw; color: #ccc; line-height: 1.3; padding: 0 5px; word-break: keep-all; flex: 1; display: flex; align-items: center; justify-content: center;}
        .card-rare { color: #ffd700; font-size: 2.5vw; margin-top: 5px; margin-bottom: 10px; border: 1px solid #ffd700; padding: 2px 8px; border-radius: 10px;}

        @media (min-width: 600px) {
            #card-selection h2 { font-size: 30px; }
            #card-selection p { font-size: 16px; }
            .card-icon { font-size: 50px; }
            .card-title { font-size: 18px; }
            .card-desc { font-size: 14px; }
            .card-rare { font-size: 12px; }
            .cards-container { width: 80%; height: 50%; gap: 20px;}
            .card { width: 160px; height: 240px; }
        }

        /* ì—…ê·¸ë ˆì´ë“œ íŒ¨ë„ */
        #upgrade-panel {
            position: absolute;
            bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700; border-radius: 15px;
            padding: 15px;
            display: none;
            flex-direction: column; align-items: center;
            z-index: 50; width: 60%; max-width: 300px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        .action-btn { padding: 12px; border:none; border-radius:8px; width:100%; margin-top:8px; font-weight:bold; cursor:pointer; font-size: 14px;}
        .btn-upgrade { background:#ffd700; color:#000; }
        .btn-sell { background: #e74c3c; color: white; }
        .btn-close { background:#444; color:#fff; }

        /* í•˜ë‹¨ ìœ ë‹› ì„ íƒ ë°” */
        #bottom-bar {
            height: 90px;
            background: #1e1e1e;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
            border-top: 2px solid #333;
            z-index: 10;
        }

        .unit-btn {
            background: #333;
            border: 2px solid #444;
            border-radius: 8px;
            width: 15%;
            height: 90%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .unit-btn.selected { border-color: #ffd700; background: #4a4a3a; }
        .unit-btn.disabled { opacity: 0.4; filter: grayscale(100%); }
        .unit-cost { font-size: 11px; color: #ffd700; font-weight: bold; }

        /* ì˜¤ë²„ë ˆì´ (ê²Œì„ì˜¤ë²„/ì‹œì‘) */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }
        .big-btn { padding: 15px 40px; font-size: 24px; background: #ffd700; border: none; border-radius: 30px; font-weight: bold; cursor: pointer; margin-top: 20px; }
        
        #rank-info {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-top: 15px;
            width: 80%;
            max-width: 300px;
            border: 1px solid #555;
        }
        .rank-stat { font-size: 18px; color: #ccc; margin: 5px 0; }
        .rank-val { color: #ffd700; font-weight: bold; font-size: 22px; }

    </style>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let currentUser = null;

        // ì¸ì¦ ì´ˆê¸°í™”
        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };
        initAuth();
        onAuthStateChanged(auth, (user) => { currentUser = user; });

        // ì ìˆ˜ ì €ì¥ ë° ë­í‚¹ ì¡°íšŒ í•¨ìˆ˜ (windowì— ë“±ë¡í•˜ì—¬ ë©”ì¸ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ í˜¸ì¶œ)
        window.submitScoreAndGetRank = async (finalScore) => {
            if (!currentUser) return { rank: '-', top: '-' };

            const col = collection(db, 'artifacts', appId, 'public', 'data', 'scores');
            
            try {
                // 1. ì ìˆ˜ ì €ì¥
                await addDoc(col, {
                    score: finalScore,
                    ts: serverTimestamp()
                });

                // 2. ì „ì²´ ì ìˆ˜ ê°€ì ¸ì˜¤ê¸° (ë‹¨ìˆœ ì¿¼ë¦¬ ê·œì¹™ ì¤€ìˆ˜)
                const snapshot = await getDocs(col);
                const scores = [];
                snapshot.forEach(doc => {
                    if (typeof doc.data().score === 'number') {
                        scores.push(doc.data().score);
                    }
                });

                // 3. ì •ë ¬ (ë‚´ë¦¼ì°¨ìˆœ)
                scores.sort((a, b) => b - a);

                // 4. ë‚´ ë“±ìˆ˜ ë° 1ë“± ì ìˆ˜ ê³„ì‚°
                const rank = scores.indexOf(finalScore) + 1;
                const top = scores[0];

                return { rank, top };
            } catch(e) {
                console.error("Rank Error:", e);
                return { rank: '?', top: '?' };
            }
        };
    </script>
</head>
<body>

    <div id="top-hud">
        <div class="hud-item">
            <span>âš¡</span><span class="energy-count" id="ui-energy">150</span>
            <span class="score-display">(ì ìˆ˜: <span id="ui-score">0</span>)</span>
        </div>
        <div class="hud-item">
            <span class="wave-text" id="ui-wave">Wave 1</span>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="wave-progress"></div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- ì¹´ë“œ ì„ íƒ UI -->
        <div id="card-selection">
            <h2>ğŸ‰ Wave Clear!</h2>
            <p>ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”</p>
            <div class="cards-container" id="cards-box"></div>
        </div>

        <!-- ìœ ë‹› ê°œë³„ ì—…ê·¸ë ˆì´ë“œ UI -->
        <div id="upgrade-panel">
            <div id="upgrade-info" style="font-weight:bold; font-size:18px; color:#ffd700; margin-bottom:5px;">Lv.1 í°</div>
            <div id="upgrade-stats" style="color:#ccc; font-size:12px; margin-bottom:5px;">ìŠ¤íƒ¯ ì •ë³´</div>
            <button class="action-btn btn-upgrade" id="btn-do-upgrade" onclick="upgradeSelectedUnit()">ê°•í™”</button>
            <button class="action-btn btn-sell" id="btn-do-sell" onclick="sellSelectedUnit()">íŒë§¤</button>
            <button class="action-btn btn-close" onclick="closeUpgradePanel()">ë‹«ê¸°</button>
        </div>

        <!-- ì‹œì‘/ì¢…ë£Œ í™”ë©´ -->
        <div id="overlay">
            <h1 style="color:#ffd700; margin-bottom:10px; font-size:32px;">ğŸƒ Chess Defense</h1>
            <p id="overlay-msg" style="color:#ccc; text-align:center; margin-bottom:20px; line-height:1.5;">
                ë­í‚¹ ì‹œìŠ¤í…œ ë„ì…!<br>
                ë‹¹ì‹ ì˜ ì ìˆ˜ëŠ” ê¸°ë¡ë©ë‹ˆë‹¤.
            </p>
            
            <!-- ë­í‚¹ í‘œì‹œ ì˜ì—­ (ê²Œì„ ì˜¤ë²„ ì‹œ í‘œì‹œ) -->
            <div id="rank-info" style="display:none;">
                <div class="rank-stat">ë‚´ ì ìˆ˜</div>
                <div class="rank-val" id="res-score">0</div>
                <hr style="border-color:#444; margin:10px 0;">
                <div class="rank-stat">ë‚´ ìˆœìœ„</div>
                <div class="rank-val" id="res-rank" style="color:#00e5ff;">ê³„ì‚° ì¤‘...</div>
                <div class="rank-stat" style="font-size:14px; margin-top:10px;">ğŸ† ì „ì²´ 1ë“±: <span id="res-top" style="color:#fff;">-</span></div>
            </div>

            <button class="big-btn" id="start-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <div id="bottom-bar">
        <div class="unit-btn" id="btn-king" onclick="selectUnitType('king')">
            <div class="unit-icon" style="font-size:24px">â™š</div>
            <div class="unit-cost">80</div>
            <div style="font-size:9px; color:#ccc">í‚¹(ìì›)</div>
        </div>
        <div class="unit-btn" id="btn-pawn" onclick="selectUnitType('pawn')">
            <div class="unit-icon" style="font-size:24px">â™Ÿï¸</div>
            <div class="unit-cost">50</div>
            <div style="font-size:9px; color:#ccc">í°(ë°©íŒ¨)</div>
        </div>
        <div class="unit-btn" id="btn-rook" onclick="selectUnitType('rook')">
            <div class="unit-icon" style="font-size:24px">â™œ</div>
            <div class="unit-cost">100</div>
            <div style="font-size:9px; color:#ccc">ë£©(ì§ì„ )</div>
        </div>
        <div class="unit-btn" id="btn-bishop" onclick="selectUnitType('bishop')">
            <div class="unit-icon" style="font-size:24px">â™</div>
            <div class="unit-cost">120</div>
            <div style="font-size:9px; color:#ccc">ë¹„ìˆ(ëŒ€ê°)</div>
        </div>
        <div class="unit-btn" id="btn-knight" onclick="selectUnitType('knight')">
            <div class="unit-icon" style="font-size:24px">â™</div>
            <div class="unit-cost">150</div>
            <div style="font-size:9px; color:#ccc">ë‚˜ì´íŠ¸(ë²”ìœ„)</div>
        </div>
        <div class="unit-btn" id="btn-queen" onclick="selectUnitType('queen')">
            <div class="unit-icon" style="font-size:24px">â™›</div>
            <div class="unit-cost">250</div>
            <div style="font-size:9px; color:#ccc">í€¸(ë©€í‹°)</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GAME_WIDTH = 900;
    const GAME_HEIGHT = 500;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    const CELL_SIZE = 100;
    const COLS = 9;
    const ROWS = 5;

    let isPlaying = false;
    let isPaused = false;
    let energy = 150;
    let score = 0; // ğŸ† ëˆ„ì  ì ìˆ˜ ë³€ìˆ˜ ì¶”ê°€
    let frame = 0;
    
    let wave = 1;
    let enemiesToSpawn = 0;
    let enemiesSpawned = 0;
    let enemiesKilled = 0;
    let waveTotalEnemies = 0;

    let globalBuffs = { 
        dmgMult: 1.0, spdMult: 1.0, costMult: 1.0, hpMult: 1.0, kingGold: 0,
        enemySpeedMult: 1.0, goldPerKill: 0, rangeMult: 1.0, critChance: 0, sellRefund: 0.5
    };

    let selectedType = null;
    let focusedUnit = null;

    let defenders = [];
    let enemies = [];
    let projectiles = [];
    let particles = [];
    let floatingTexts = [];

    const UNITS = {
        'king':   { cost: 100,  hp: 200, dmg: 1,   spd: 120, upCost: 100, color: '#ffd700', icon: 'â™š', name: 'í‚¹' },
        'pawn':   { cost: 50,  hp: 400, dmg: 10,  spd: 60,  upCost: 30,  color: '#aaa',    icon: 'â™Ÿï¸', name: 'í°' },
        'rook':   { cost: 210, hp: 200, dmg: 30,  spd: 50,  upCost: 120, color: '#4a90e2', icon: 'â™œ', name: 'ë£©' },
        'bishop': { cost: 120, hp: 150, dmg: 40,  spd: 60,  upCost: 150, color: '#9013fe', icon: 'â™', name: 'ë¹„ìˆ' },
        'knight': { cost: 200, hp: 300, dmg: 37,  spd: 40,  upCost: 200, color: '#7ed321', icon: 'â™', name: 'ë‚˜ì´íŠ¸' },
        'queen':  { cost: 500, hp: 500, dmg: 25,  spd: 45,  upCost: 300, color: '#ff00ff', icon: 'â™›', name: 'í€¸' }
    };

    const CARD_POOL = [
        { id: 'atk_up',   icon: 'âš”ï¸', title: 'ì „êµ° ëŒê²©', desc: 'ì•„êµ° ê³µê²©ë ¥ +20%' },
        { id: 'spd_up',   icon: 'âš¡', title: 'ê´‘ì† ëª¨ë“œ', desc: 'ì•„êµ° ê³µì† +15%' },
        { id: 'hp_up',    icon: 'ğŸ›¡ï¸', title: 'ê°•ì²  ê°‘ì˜·', desc: 'ì•„êµ° ì²´ë ¥ +25%' },
        { id: 'cost_dn',  icon: 'ğŸ’°', title: 'ìì› ì ˆì•½', desc: 'ë°°ì¹˜ ë¹„ìš© -10%' },
        { id: 'king_up',  icon: 'ğŸ‘‘', title: 'ì™•ì˜ ì„¸ê¸ˆ', desc: 'í‚¹ ìì›ìƒì‚° +5' },
        { id: 'rich',     icon: 'ğŸ’', title: 'ë³´ê¸‰í’ˆ',    desc: 'ì¦‰ì‹œ ìì› +200' },
        { id: 'heal_all', icon: 'ğŸ’Š', title: 'ê¸´ê¸‰ ìˆ˜ë¦¬', desc: 'ëª¨ë“  ì•„êµ° ì²´ë ¥ 100% íšŒë³µ' },
        { id: 'slow',     icon: 'â„ï¸', title: 'ì–¼ìŒ ì§€ëŒ€', desc: 'ì  ì´ë™ì†ë„ -10%' },
        { id: 'bounty',   icon: 'ğŸ’°', title: 'í˜„ìƒê¸ˆ',    desc: 'ì  ì²˜ì¹˜ ì‹œ +3ê³¨ë“œ' },
        { id: 'range',    icon: 'ğŸ”­', title: 'ì €ê²© í›ˆë ¨', desc: 'í°/ë‚˜ì´íŠ¸ ì‚¬ê±°ë¦¬ +20%' },
        { id: 'crit',     icon: 'âš¡', title: 'ì¹˜ëª…íƒ€',    desc: '10% í™•ë¥ ë¡œ 2ë°° ë°ë¯¸ì§€' },
        { id: 'recycle',  icon: 'â™»ï¸', title: 'ì¬í™œìš©',    desc: 'íŒë§¤ í™˜ê¸‰ë¥  80%ë¡œ ì¦ê°€' }
    ];

    const ENEMY_TYPES = [
        { minWave: 1,  type: 'normal', color: '#e74c3c', hpMult: 1.0, spdMult: 1.0, radius: 35, ability: null },
        { minWave: 5,  type: 'fast',   color: '#f1c40f', hpMult: 0.6, spdMult: 1.5, radius: 25, ability: 'dodge' },
        { minWave: 10, type: 'tank',   color: '#8e44ad', hpMult: 2.5, spdMult: 0.6, radius: 45, ability: 'armor' },
        { minWave: 15, type: 'boss',   color: '#2c3e50', hpMult: 5.0, spdMult: 0.4, radius: 50, ability: 'stun' }
    ];

    function startGame() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('rank-info').style.display = 'none'; // ë­í‚¹ ìˆ¨ê¹€
        initGame();
        startWave(1);
        animate();
    }

    function initGame() {
        defenders = []; enemies = []; projectiles = []; particles = []; floatingTexts = [];
        energy = 150; score = 0; frame = 0; isPlaying = true; isPaused = false;
        globalBuffs = { 
            dmgMult: 1.0, spdMult: 1.0, costMult: 1.0, hpMult: 1.0, kingGold: 0,
            enemySpeedMult: 1.0, goldPerKill: 0, rangeMult: 1.0, critChance: 0, sellRefund: 0.5
        };
        closeUpgradePanel();
        updateUI();
    }

    function startWave(waveNum) {
        wave = waveNum; enemiesSpawned = 0; enemiesKilled = 0;
        waveTotalEnemies = 5 + Math.floor(wave * 2.5); 
        enemiesToSpawn = waveTotalEnemies;
        spawnFloatingText(`Wave ${wave} Start!`, GAME_WIDTH/2, GAME_HEIGHT/2, '#00e5ff');
        updateUI();
    }

    function checkWaveClear() {
        if (enemiesKilled >= waveTotalEnemies) showCardSelection();
    }

    function showCardSelection() {
        isPaused = true;
        const cardBox = document.getElementById('cards-box');
        cardBox.innerHTML = ''; 
        const shuffled = [...CARD_POOL].sort(() => 0.5 - Math.random());
        const picks = shuffled.slice(0, 3);

        picks.forEach(card => {
            const el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `
                <div class="card-icon">${card.icon}</div>
                <div class="card-title">${card.title}</div>
                <div class="card-desc">${card.desc}</div>
                <div class="card-rare">ì„ íƒ</div>
            `;
            el.onclick = () => selectCard(card.id);
            cardBox.appendChild(el);
        });
        document.getElementById('card-selection').style.display = 'flex';
    }

    function selectCard(cardId) {
        switch(cardId) {
            case 'atk_up': globalBuffs.dmgMult += 0.2; break;
            case 'spd_up': globalBuffs.spdMult += 0.15; break;
            case 'hp_up':  globalBuffs.hpMult += 0.25; break;
            case 'cost_dn': globalBuffs.costMult *= 0.9; break;
            case 'king_up': globalBuffs.kingGold += 5; break;
            case 'rich': 
                energy += 200; score += 200; // ë³´ë„ˆìŠ¤ ì ìˆ˜
                break;
            case 'heal_all': 
                defenders.forEach(d => { d.hp = d.maxHp; spawnFloatingText("Heal!", d.x+50, d.y, '#00ff00'); }); 
                break;
            case 'slow': globalBuffs.enemySpeedMult *= 0.9; break;
            case 'bounty': globalBuffs.goldPerKill += 3; break;
            case 'range': globalBuffs.rangeMult += 0.2; break;
            case 'crit': globalBuffs.critChance += 0.1; break;
            case 'recycle': globalBuffs.sellRefund = 0.8; break;
        }

        defenders.forEach(d => d.applyBuffs());
        document.getElementById('card-selection').style.display = 'none';
        isPaused = false;
        startWave(wave + 1);
        updateUI();
    }

    function updateUI() {
        document.getElementById('ui-energy').innerText = Math.floor(energy);
        document.getElementById('ui-score').innerText = Math.floor(score);
        document.getElementById('ui-wave').innerText = `Wave ${wave}`;
        
        const progress = Math.min(100, (enemiesKilled / waveTotalEnemies) * 100);
        document.getElementById('wave-progress').style.width = `${progress}%`;

        ['king', 'pawn', 'rook', 'bishop', 'knight', 'queen'].forEach(t => {
            const btn = document.getElementById(`btn-${t}`);
            const realCost = Math.floor(UNITS[t].cost * globalBuffs.costMult);
            btn.querySelector('.unit-cost').innerText = realCost;
            if (selectedType === t) btn.classList.add('selected'); else btn.classList.remove('selected');
            if (energy < realCost) btn.classList.add('disabled'); else btn.classList.remove('disabled');
        });
    }

    window.selectUnitType = function(type) {
        if (!isPlaying || isPaused) return;
        if (selectedType === type) selectedType = null;
        else selectedType = type;
        closeUpgradePanel();
        updateUI();
    };

    function handleInput(cx, cy) {
        if (!isPlaying || isPaused) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (cx - rect.left) * scaleX;
        const y = (cy - rect.top) * scaleY;
        const gx = Math.floor(x / CELL_SIZE) * CELL_SIZE;
        const gy = Math.floor(y / CELL_SIZE) * CELL_SIZE;

        if (gx >= GAME_WIDTH - CELL_SIZE || gx < 0 || gy < 0 || gy >= GAME_HEIGHT) {
            selectedType = null; closeUpgradePanel(); updateUI(); return;
        }

        const clickedUnit = defenders.find(d => d.x === gx && d.y === gy);

        if (clickedUnit) {
            openUpgradePanel(clickedUnit);
            selectedType = null;
        } else if (selectedType) {
            const baseCost = UNITS[selectedType].cost;
            const finalCost = Math.floor(baseCost * globalBuffs.costMult);
            if (energy >= finalCost) {
                defenders.push(new Defender(gx, gy, selectedType));
                energy -= finalCost;
                spawnParticles(gx+50, gy+50, 10, '#ffd700');
                selectedType = null; updateUI();
            }
        } else {
            closeUpgradePanel();
        }
    }

    function openUpgradePanel(unit) {
        focusedUnit = unit;
        const panel = document.getElementById('upgrade-panel');
        const nextCost = unit.getUpgradeCost();
        
        const baseCost = UNITS[unit.type].cost;
        const invest = baseCost + ((unit.level - 1) * UNITS[unit.type].upCost);
        const sellPrice = Math.floor(invest * globalBuffs.sellRefund);

        document.getElementById('upgrade-info').innerText = `Lv.${unit.level} ${UNITS[unit.type].name}`;
        let statText = (unit.type === 'king') ? `ìƒì‚°ëŸ‰ +5` : `ê³µê²©ë ¥ +30%`;
        document.getElementById('upgrade-stats').innerText = statText;
        
        const btnUp = document.getElementById('btn-do-upgrade');
        btnUp.innerText = `ê°•í™” (${nextCost}G)`;
        btnUp.style.opacity = (energy < nextCost) ? 0.5 : 1.0;

        const btnSell = document.getElementById('btn-do-sell');
        btnSell.innerText = `íŒë§¤ (+${sellPrice}G)`;

        panel.style.display = 'flex';
    }

    window.closeUpgradePanel = () => { document.getElementById('upgrade-panel').style.display = 'none'; focusedUnit = null; };
    
    window.upgradeSelectedUnit = () => {
        if (!focusedUnit) return;
        const cost = focusedUnit.getUpgradeCost();
        if (energy >= cost) {
            energy -= cost;
            focusedUnit.levelUp();
            spawnParticles(focusedUnit.x+50, focusedUnit.y+50, 20, '#fff');
            spawnFloatingText("LEVEL UP!", focusedUnit.x+50, focusedUnit.y);
            openUpgradePanel(focusedUnit); updateUI();
        }
    };

    window.sellSelectedUnit = () => {
        if (!focusedUnit) return;
        const baseCost = UNITS[focusedUnit.type].cost;
        const invest = baseCost + ((focusedUnit.level - 1) * UNITS[focusedUnit.type].upCost);
        const sellPrice = Math.floor(invest * globalBuffs.sellRefund);

        energy += sellPrice;
        spawnFloatingText(`+${sellPrice} G`, focusedUnit.x+50, focusedUnit.y, '#ffd700');
        spawnParticles(focusedUnit.x+50, focusedUnit.y+50, 15, '#888');

        defenders = defenders.filter(d => d !== focusedUnit);
        closeUpgradePanel();
        updateUI();
    };

    canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

    class Defender {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.level = 1; this.baseStats = UNITS[type];
            this.color = this.baseStats.color; this.icon = this.baseStats.icon;
            this.timer = 0; this.applyBuffs(); this.hp = this.maxHp;
            this.stunTimer = 0;
        }

        applyBuffs() {
            const lvlMult = Math.pow(1.2, this.level - 1);
            this.maxHp = Math.floor(this.baseStats.hp * lvlMult * globalBuffs.hpMult);
            
            if (this.type === 'king') {
                this.damage = Math.floor(this.baseStats.dmg + ((this.level-1)*5) + globalBuffs.kingGold);
            } else {
                this.damage = Math.floor(this.baseStats.dmg * Math.pow(1.3, this.level - 1) * globalBuffs.dmgMult);
            }
            this.cd = Math.max(10, Math.floor(this.baseStats.spd / globalBuffs.spdMult));
            this.hp = Math.min(this.hp, this.maxHp);
        }

        getUpgradeCost() { return Math.floor(this.baseStats.upCost * this.level); }
        levelUp() { this.level++; this.applyBuffs(); this.hp = this.maxHp; }

        update() {
            if (this.stunTimer > 0) {
                this.stunTimer--;
                return;
            }
            this.timer++; if (this.timer % this.cd === 0) this.act();
        }

        act() {
            const cx = this.x + 50, cy = this.y + 50;
            if (this.type === 'king') {
                energy += this.damage; 
                score += this.damage; // ğŸ† ìƒì‚° ì ìˆ˜
                spawnFloatingText(`+${this.damage}`, cx, this.y, '#ffd700'); updateUI(); return;
            }
            
            let finalDmg = this.damage;
            let isCrit = false;
            if (Math.random() < globalBuffs.critChance) {
                finalDmg *= 2;
                isCrit = true;
            }

            if (this.type === 'knight') { 
                 let range = 330 * globalBuffs.rangeMult;
                 let hit = false;
                 enemies.forEach(e => {
                    if (Math.hypot((e.x+50)-cx, (e.y+50)-cy) < range) {
                        e.takeDamage(finalDmg, isCrit);
                        spawnParticles(e.x+50, e.y+50, 2, '#fff');
                        hit = true;
                    }
                });
                if(hit) this.effect = true;
            } else if (this.type === 'bishop') {
                 projectiles.push(new Projectile(cx, cy, finalDmg, -0.6, this.color, isCrit));
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0.6, this.color, isCrit));
            } else if (this.type === 'queen') {
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0, this.color, isCrit));
                 projectiles.push(new Projectile(cx, cy, finalDmg, -0.6, this.color, isCrit));
                 projectiles.push(new Projectile(cx, cy, finalDmg, 0.6, this.color, isCrit));
            } else { 
                let range = (this.type === 'pawn') ? (180 * globalBuffs.rangeMult) : 900;
                if (enemies.some(e => e.y === this.y && e.x > this.x && e.x < this.x + range)) {
                    projectiles.push(new Projectile(cx, cy, finalDmg, 0, this.color, isCrit));
                }
            }
        }

        draw() {
            ctx.fillStyle = '#333'; ctx.fillRect(this.x+5, this.y+5, 90, 90);
            ctx.fillStyle = this.color; ctx.font = '50px Arial'; ctx.textAlign = 'center'; ctx.fillText(this.icon, this.x+50, this.y+65);
            
            if (this.stunTimer > 0) {
                ctx.font = '30px Arial'; ctx.fillText('ğŸ’«', this.x+50, this.y+40);
            }

            let stars = "â­".repeat(Math.min(3, this.level)); if (this.level > 3) stars = `â­Lv.${this.level}`;
            ctx.font = '12px Arial'; ctx.fillStyle = '#fff'; ctx.fillText(stars, this.x+50, this.y+20);
            const pct = this.hp/this.maxHp;
            ctx.fillStyle = '#000'; ctx.fillRect(this.x+10, this.y+80, 80, 6);
            ctx.fillStyle = pct > 0.3 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(this.x+10, this.y+80, 80*pct, 6);
            if(this.effect) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); 
                ctx.arc(this.x+50, this.y+50, 330 * globalBuffs.rangeMult / 2, 0, Math.PI*2); ctx.stroke();
                this.effect = false;
            }
        }
    }

    class Enemy {
        constructor() {
            this.y = Math.floor(Math.random() * ROWS) * CELL_SIZE;
            this.x = GAME_WIDTH;
            
            const available = ENEMY_TYPES.filter(e => wave >= e.minWave);
            const typeData = available[Math.floor(Math.random() * available.length)];
            
            this.type = typeData.type;
            this.color = typeData.color;
            this.radius = typeData.radius;
            this.ability = typeData.ability;

            let baseHp = 80 + (wave * 30);
            if (wave === 1) baseHp *= 0.5;
            
            this.hp = baseHp * typeData.hpMult;
            this.maxHp = this.hp;

            let baseSpeed = Math.random() * 0.4 + 0.4 + (wave * 0.02);
            this.speed = baseSpeed * typeData.spdMult;
            this.moveSpeed = this.speed;
            
            this.skillTimer = 0;
        }
        update() {
            this.moveSpeed = this.speed * globalBuffs.enemySpeedMult;
            
            if (this.ability === 'stun') {
                this.skillTimer++;
                if (this.skillTimer > 300) {
                    this.skillTimer = 0;
                    let stunned = false;
                    defenders.forEach(d => {
                        if (Math.hypot((d.x+50)-this.x, (d.y+50)-this.y) < 200) {
                            d.stunTimer = 120;
                            spawnFloatingText("Stun!", d.x+50, d.y, '#ffff00');
                            stunned = true;
                        }
                    });
                    if(stunned) spawnParticles(this.x, this.y+50, 20, '#ffff00');
                }
            }

            for (let d of defenders) {
                if (d.y === this.y && this.x < d.x + 80 && this.x > d.x) {
                    this.moveSpeed = 0; d.hp -= 0.5;
                    if (d.hp <= 0) { defenders = defenders.filter(u => u !== d); closeUpgradePanel(); }
                }
            }
            this.x -= this.moveSpeed;
        }
        
        takeDamage(amount, isCrit) { 
            if (this.ability === 'dodge' && Math.random() < 0.3) {
                spawnFloatingText("Miss", this.x+50, this.y, '#ccc', 14);
                return;
            }
            if (this.ability === 'armor') {
                amount = Math.max(1, amount - 10);
                if (Math.random() < 0.3) spawnFloatingText("Block", this.x+50, this.y-20, '#888', 12);
            }
            this.hp -= amount; 
            spawnFloatingText(Math.floor(amount), this.x+50, this.y, isCrit ? '#ff00ff' : '#ff4444', isCrit ? 24 : 18); 
        }
        
        draw() {
            ctx.fillStyle = this.color; 
            ctx.beginPath(); ctx.arc(this.x+50, this.y+50, this.radius, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x+35, this.y+45, 8, 0, Math.PI*2); ctx.arc(this.x+65, this.y+45, 8, 0, Math.PI*2); ctx.fill();
            
            // ğŸ”¥ ì²´ë ¥ë°” ìœ„ì¹˜ ë³´ì •: ë§¨ ìœ„ ì¤„(y < 10)ì´ë©´ ë°œ ë°‘ì— í‘œì‹œ, ì•„ë‹ˆë©´ ë¨¸ë¦¬ ìœ„ì— í‘œì‹œ
            let hpY = (this.y < 10) ? this.y + 85 : this.y - 15;

            ctx.fillStyle = '#000'; ctx.fillRect(this.x+20, hpY, 60, 5);
            ctx.fillStyle = this.color; ctx.fillRect(this.x+20, hpY, 60*(this.hp/this.maxHp), 5);
            
            if (globalBuffs.enemySpeedMult < 1.0) {
                 ctx.fillStyle = '#00e5ff'; ctx.font = '12px Arial'; ctx.fillText('â„ï¸', this.x+50, this.y+80);
            }
        }
    }

    class Projectile {
        constructor(x, y, dmg, dy, color, isCrit) { 
            this.x = x; this.y = y; this.dmg = dmg; this.dy = dy; this.color = color; 
            this.speed = 10; this.isCrit = isCrit;
        }
        update() { this.x += this.speed; this.y += this.dy * this.speed; }
        draw() { 
            ctx.fillStyle = this.isCrit ? '#fff' : this.color; 
            ctx.beginPath(); 
            ctx.arc(this.x, this.y, this.isCrit ? 10 : 8, 0, Math.PI*2); 
            ctx.fill(); 
            if(this.isCrit) {
                ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.stroke();
            }
        }
    }

    class FloatingText {
        constructor(text, x, y, color='#fff', size=18) { 
            this.text = text; this.x = x; this.y = y; this.color = color; this.size = size;
            this.life = 1.0; this.dy = -1; 
        }
        update() { this.y += this.dy; this.life -= 0.03; }
        draw() { 
            ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; 
            ctx.font = `bold ${this.size}px Arial`; ctx.textAlign='center'; 
            ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0; 
        }
    }
    function spawnFloatingText(text, x, y, color, size) { floatingTexts.push(new FloatingText(text, x, y, color, size)); }

    class Particle {
        constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.vx = (Math.random()-0.5)*5; this.vy = (Math.random()-0.5)*5; this.life = 1.0; }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
    }
    function spawnParticles(x, y, c, color) { for(let i=0; i<c; i++) particles.push(new Particle(x, y, color)); }

    function animate() {
        if (!isPlaying) return;
        requestAnimationFrame(animate);
        if (isPaused) return;

        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        for (let r=0; r<ROWS; r++) {
            for (let c=0; c<COLS; c++) {
                ctx.fillStyle = (r+c)%2===0 ? '#222' : '#2a2a2a'; ctx.fillRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }
        if (selectedType) { ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3; ctx.strokeRect(0, 0, GAME_WIDTH-CELL_SIZE, GAME_HEIGHT); }
        if (focusedUnit) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.strokeRect(focusedUnit.x, focusedUnit.y, CELL_SIZE, CELL_SIZE); }

        if (enemiesSpawned < enemiesToSpawn) {
            let spawnRate = Math.max(60, 300 - (wave * 30)); 
            if (frame % spawnRate === 0) { enemies.push(new Enemy()); enemiesSpawned++; }
        }

        defenders.forEach(d => d.update());
        defenders.sort((a,b) => a.y - b.y);
        defenders.forEach(d => d.draw());

        enemies.forEach((e, i) => {
            e.update(); e.draw();
            // ğŸ’€ ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
            if (e.x < 0) {
                isPlaying = false;
                document.querySelector('#overlay h1').innerText = "GAME OVER";
                document.querySelector('#overlay-msg').innerText = "ì ìˆ˜ë¥¼ ì €ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
                document.getElementById('overlay').style.display = 'flex';
                document.getElementById('start-btn').style.display = 'none'; // ë¡œë”© ì¤‘ ë²„íŠ¼ ìˆ¨ê¹€
                document.getElementById('rank-info').style.display = 'block';
                
                document.getElementById('res-score').innerText = Math.floor(score);

                // ğŸ”¥ ë­í‚¹ ì„œë²„ ì „ì†¡ ë° ì¡°íšŒ
                if(window.submitScoreAndGetRank) {
                    window.submitScoreAndGetRank(Math.floor(score)).then(res => {
                        document.getElementById('res-rank').innerText = `${res.rank}ìœ„`;
                        document.getElementById('res-top').innerText = `${res.top}`;
                        document.querySelector('#overlay-msg').innerText = "ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!";
                        document.getElementById('start-btn').innerText = "ë‹¤ì‹œ í•˜ê¸°";
                        document.getElementById('start-btn').style.display = 'block';
                    });
                }
            }
            if (e.hp <= 0) {
                enemies.splice(i, 1); 
                let gain = 10 + globalBuffs.goldPerKill;
                energy += gain; 
                score += gain; // ğŸ† í‚¬ ì ìˆ˜
                enemiesKilled++; updateUI();
                spawnParticles(e.x+50, e.y+50, 10, '#e74c3c');
                checkWaveClear();
            }
        });
        projectiles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.x > GAME_WIDTH || p.y < 0 || p.y > GAME_HEIGHT) { projectiles.splice(i, 1); return; }
            for (let e of enemies) {
                if (Math.hypot((e.x+50)-p.x, (e.y+50)-p.y) < (40 + e.radius - 35)) {
                    e.takeDamage(p.dmg, p.isCrit); 
                    spawnParticles(p.x, p.y, 3, p.color); projectiles.splice(i, 1); break;
                }
            }
        });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });
        floatingTexts.forEach((t, i) => { t.update(); t.draw(); if (t.life <= 0) floatingTexts.splice(i, 1); });

        frame++;
    }
</script>
</body>
</html>
