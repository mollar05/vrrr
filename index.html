<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프로젝트: 와일드 (Optimized Edition)</title>
    <!-- Simplex Noise 라이브러리 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', sans-serif; background: #000; overflow: hidden; }
        #game-container { width: 100vw; height: 100vh; position: relative; }

        /* [UI] 실시간 좌표 및 바이옴 표시 */
        #coord-display { position: fixed; top: 20px; left: 20px; color: #00ff00; font-size: 20px; font-weight: 700; font-family: 'Consolas', monospace; text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8); z-index: 102; pointer-events: none; background: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 5px; border: 1px solid #00ff00; }
        /* [UI] 게임 시간 표시 */
        #time-display { position: fixed; top: 65px; left: 20px; color: #00ffff; font-size: 20px; font-weight: 700; font-family: 'Consolas', monospace; text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.8); z-index: 102; pointer-events: none; background: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 5px; border: 1px solid #00ffff; }
        /* 몰록(화폐) 스코어 표시 UI */
        #moloch-display { position: fixed; top: 30px; right: 50px; color: #ffd700; font-size: 28px; font-weight: 700; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); z-index: 101; letter-spacing: 1px; pointer-events: none; }
        /* [NEW] 도전과제 알림 배너 */
        #achievement-popup { position: fixed; top: 80px; right: 50px; background: linear-gradient(90deg, #FFD700, #FFA500); color: #000; padding: 10px 20px; border-radius: 8px; box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); z-index: 105; display: none; text-align: right; transform: translateX(100%); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); border: 2px solid #fff; }
        #achievement-title { font-weight: 900; font-size: 18px; text-transform: uppercase; }
        #achievement-desc { font-size: 14px; font-weight: 500; }
        /* [UI] 퀘스트 UI */
        #quest-display { position: fixed; top: 150px; right: 50px; color: #fff; text-align: right; display: none; z-index: 101; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); background: rgba(0, 0, 0, 0.4); padding: 10px; border-radius: 8px; border-right: 3px solid #00ff00; }
        #quest-title { font-size: 18px; font-weight: bold; color: #00ff00; margin-bottom: 5px; text-transform: uppercase; }
        #quest-objective { font-size: 16px; color: #ddd; }
        .quest-ready { color: #ffff00 !important; font-weight: bold; animation: text-pulse 1s infinite; }
        @keyframes text-pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        /* [NEW] 보스 바 UI (마인크래프트 스타일) */
        #boss-container {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: none; /* 보스 근처에 가면 flex로 변경 */
            flex-direction: column;
            align-items: center;
            z-index: 2000;
            pointer-events: none;
        }
        #boss-name {
            color: #fff;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 2px 2px 0 #000;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #boss-bar-bg {
            width: 100%;
            height: 24px;
            background: rgba(30, 0, 30, 0.8);
            border: 2px solid #fff;
            border-radius: 4px;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        #boss-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #9c27b0, #e91e63);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px #e91e63;
        }
        /* 보스 종류별 색상 변경 클래스 */
        .boss-fire #boss-name { text-shadow: 0 0 5px #ff4500, 0 0 10px #ff4500, 2px 2px 0 #000; }
        .boss-fire #boss-bar-fill { background: linear-gradient(90deg, #ff4500, #ff8c00); box-shadow: 0 0 10px #ff4500; }

        #crosshair { position: fixed; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); z-index: 1000; pointer-events: none; display: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: #fff; opacity: 0.8; }
        #crosshair::before { width: 2px; height: 20px; left: 50%; transform: translateX(-50%); }
        #crosshair::after { width: 20px; height: 2px; top: 50%; transform: translateY(-50%); }
        /* 줌 상태일 때 크로스헤어 변경 */
        .zoomed #crosshair::before, .zoomed #crosshair::after { background: #00ff00; box-shadow: 0 0 5px #00ff00; }
        
        #ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; color: white; display: flex; justify-content: space-between; align-items: flex-end; padding: 30px 50px; }
        .ui-group { display: flex; flex-direction: column; gap: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
        .status-row { display: flex; align-items: center; }
        .status-label { width: 80px; font-weight: 500; text-align: right; margin-right: 15px; }
        .bar-container { width: 200px; height: 20px; background: rgba(0, 0, 0, 0.5); border: 2px solid #fff; border-radius: 10px; overflow: hidden; margin-right: 15px; }
        #health-bar { height: 20px; }
        #health-fill { height: 100%; background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); transition: width 0.3s ease; width: 100%; }
        #stamina-bar { height: 15px; border-radius: 8px; }
        #stamina-fill { height: 100%; background: #2196F3; transition: width 0.1s ease; width: 100%; }
        #vehicle-health-bar { height: 15px; border-radius: 8px; }
        #vehicle-health-fill { height: 100%; background: #3498db; transition: width 0.3s ease; width: 100%; }
        #vehicle-status-row { display: none; }
        /* [NEW] 경험치 바 스타일 */
        #xp-bar-container { width: 100%; height: 8px; background: rgba(0,0,0,0.5); position: fixed; bottom: 0; left: 0; z-index: 103; }
        #xp-fill { height: 100%; background: #9b59b6; width: 0%; transition: width 0.5s; }
        #level-badge { position: fixed; bottom: 15px; left: 20px; background: #9b59b6; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; border: 2px solid white; z-index: 103; font-size: 18px; box-shadow: 0 0 10px #9b59b6; }

        .status-text { font-size: 14px; min-width: 120px; }
        #ammo-container { text-align: right; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); display: flex; flex-direction: column; align-items: flex-end; }
        #ammo-display-group { display: flex; align-items: baseline; gap: 10px; }
        #ammo-display { font-size: 32px; font-weight: 700; line-height: 1; }
        #ammo-total { font-size: 20px; color: #ccc; }
        #weapon-name { font-size: 16px; font-weight: normal; margin-top: 5px; }
        #reload-prompt { font-size: 14px; color: #ffcc00; display: none; margin-top: 5px; }
        #interaction-prompt { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); text-align: center; font-size: 16px; background: rgba(0, 0, 0, 0.7); padding: 12px 20px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); display: none; }
        #interaction-key { font-weight: bold; background: #fff; color: #000; padding: 2px 6px; border-radius: 4px; margin-right: 8px; }
        .muzzle-flash { position: fixed; width: 100px; height: 100px; transform: translate(-50%, -50%); background: radial-gradient(circle, #ffff00 0%, #ff8800 30%, transparent 70%); border-radius: 50%; opacity: 0; pointer-events: none; z-index: 999; }
        #chat-box { position: absolute; top: 250px; right: 50px; left: auto; width: 350px; max-height: 300px; background: rgba(0, 0, 0, 0.0); border: none; padding: 0; overflow-y: hidden; display: flex; flex-direction: column; align-items: flex-end; pointer-events: none; }
        .chat-message { margin: 5px 0; padding: 8px 12px; border-radius: 5px; background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; width: fit-content; animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
        .npc-name { color: #00ff00; font-weight: bold; }
        .zombie-name { color: #FF4136; font-weight: bold; }
        .system-name { color: #ffff00; font-weight: bold; }
        .item-name { color: #4e9af1; }
        .weapon-name-chat { color: #ff9d00; font-weight: bold; }
        .loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a10; background-image: radial-gradient(circle at top right, rgba(255,255,255,0.05) 0%, transparent 50%); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 2000; }
        .loading-text { font-size: 32px; font-weight: 700; margin-bottom: 20px; letter-spacing: 2px; }
        .loading-bar-container { width: 80%; max-width: 600px; }
        .loading-bar { width: 100%; height: 5px; background: rgba(255, 255, 255, 0.1); border-radius: 5px; overflow: hidden; }
        .loading-fill { height: 100%; background: #4facfe; width: 0%; transition: width 0.5s ease-out; }
        #loading-progress { font-size: 16px; margin-top: 10px; color: #ccc; }
        #loading-tips { position: absolute; bottom: 50px; font-size: 16px; color: #aaa; padding: 10px; border-radius: 5px; max-width: 80%; text-align: center; }
        .damage-text { position: fixed; font-weight: bold; font-size: 20px; pointer-events: none; z-index: 1001; animation: damage-float 1s ease-out forwards; text-shadow: 1px 1px 2px black; }
        #player-hit-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,0,0,0.5) 0%, transparent 70%); opacity: 0; pointer-events: none; z-index: 1002; transition: opacity 0.5s; }
        #lava-damage-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,69,0,0.6) 0%, transparent 80%); opacity: 0; pointer-events: none; z-index: 1003; transition: opacity 0.3s; }
        #horde-warning { position: fixed; top: 30%; left: 50%; transform: translate(-50%, -50%); color: #ff0000; font-size: 36px; font-weight: 900; text-align: center; text-shadow: 2px 2px 0px #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none; z-index: 2500; width: 100%; letter-spacing: 2px; }
        #horde-sub-warning { font-size: 24px; color: #ffcc00; margin-top: 10px; font-weight: 700; text-shadow: 1px 1px 2px black; display: block; }
        #game-over-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: none; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 3000; }
        #game-over-text { font-size: 64px; font-weight: bold; color: #ff4444; text-shadow: 3px 3px 10px #000; }
        #restart-button { margin-top: 40px; padding: 15px 30px; font-size: 20px; color: white; background: #ff4444; border: none; border-radius: 10px; cursor: pointer; text-transform: uppercase; transition: background 0.3s, transform 0.1s; }
        #restart-button:hover { background: #ff6666; transform: scale(1.05); }
        
        /* [NEW] 엔딩 화면 스타일 */
        #ending-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(200, 240, 255, 0.9); display: none; flex-direction: column; justify-content: center; align-items: center; color: #333; z-index: 3000; animation: fadeIn 2s ease-in; }
        #ending-title { font-size: 80px; font-weight: 900; color: #00aaff; text-shadow: 2px 2px 10px rgba(255,255,255,0.8); margin-bottom: 20px; letter-spacing: 5px; }
        #ending-subtitle { font-size: 40px; font-weight: bold; color: #555; margin-bottom: 40px; }
        #ending-stats { font-size: 24px; color: #444; background: rgba(255,255,255,0.6); padding: 20px; border-radius: 10px; border: 2px solid #fff; }
        #ending-number { font-size: 20px; color: #888; margin-top: 50px; font-family: monospace; }
        
        #trade-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); border: 2px solid #ffd700; padding: 20px; border-radius: 10px; color: white; z-index: 2000; width: 400px; display: none; flex-direction: column; gap: 15px; box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
        #trade-modal h2 { color: #ffd700; text-align: center; margin-bottom: 10px; font-size: 24px; }
        #trade-list { display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto; }
        .trade-item { display: flex; justify-content: space-between; align-items: center; background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 5px; }
        .trade-item-info { font-size: 14px; }
        .sell-btn { background: #4caf50; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-size: 13px; transition: background 0.2s; }
        .sell-btn:hover { background: #45a049; }
        .sell-btn:disabled { background: #555; cursor: not-allowed; color: #aaa; }
        #close-trade-btn { background: #f44336; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; margin-top: 10px; font-weight: bold; }
        #close-trade-btn:hover { background: #d32f2f; }
        
        /* [NEW] 스탯창 UI */
        #stats-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10, 10, 20, 0.95); border: 2px solid #9b59b6; padding: 30px; border-radius: 15px; color: white; z-index: 2100; width: 350px; display: none; flex-direction: column; gap: 20px; box-shadow: 0 0 30px rgba(155, 89, 182, 0.4); }
        #stats-modal h2 { color: #9b59b6; text-align: center; margin-bottom: 10px; font-size: 28px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #9b59b6; }
        .stat-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; }
        .stat-name { font-weight: bold; font-size: 18px; width: 100px; }
        .stat-val { font-family: 'Consolas', monospace; color: #ffff00; font-size: 20px; width: 50px; text-align: center; }
        .stat-btn { background: #4caf50; color: white; border: none; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-weight: bold; font-size: 18px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .stat-btn:hover { transform: scale(1.1); background: #66bb6a; }
        .stat-btn:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }
        #stat-points-display { text-align: center; font-size: 16px; color: #ddd; margin-bottom: 10px; }
        #stat-points-val { color: #ffff00; font-weight: bold; font-size: 20px; }
        #close-stats-btn { background: #555; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 10px; transition: background 0.2s; }
        #close-stats-btn:hover { background: #777; }

        /* [NEW] 스코프 UI */
        #scope-display-container { position: fixed; bottom: 80px; right: 50px; display: flex; flex-direction: column; align-items: flex-end; z-index: 101; pointer-events: none; }
        .scope-row { display: flex; gap: 5px; margin-top: 5px; pointer-events: auto; }
        .scope-btn { background: rgba(0,0,0,0.6); border: 1px solid #555; color: #ccc; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
        .scope-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .scope-btn.active { border-color: #00ff00; color: #00ff00; background: rgba(0, 50, 0, 0.6); box-shadow: 0 0 5px #00ff00; }
        .scope-btn.locked { color: #555; border-color: #333; background: rgba(0,0,0,0.8); cursor: not-allowed; }
        #current-zoom-display { font-family: 'Consolas', monospace; color: #00ff00; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 2px black; text-align: right; }
        .zoom-label { font-size: 12px; color: #aaa; margin-right: 5px; }

        @keyframes damage-float { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-50px); opacity: 0; } }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-text">프로젝트: 와일드 (Optimized Edition)</div>
        <div class="loading-bar-container">
            <div class="loading-bar"><div class="loading-fill" id="loading-fill"></div></div>
             <div id="loading-progress">0%</div>
        </div>
        <div id="loading-tips">게임 팁: 로딩 중...</div>
    </div>

    <div id="game-container">
        <div id="crosshair"></div>
        <div id="muzzle-flash" class="muzzle-flash"></div>
        <div id="player-hit-overlay"></div>
        <div id="lava-damage-overlay"></div>
        
        <div id="coord-display">X: 0, Y: 0 <span style="font-size:0.8em; color:#ccc; margin-left:10px;" id="biome-display"></span></div>
        <div id="time-display">00:00</div>
        <div id="moloch-display">몰록 / <span id="moloch-count">0</span></div>

        <div id="achievement-popup">
            <div id="achievement-title">도전과제 달성!</div>
            <div id="achievement-desc"></div>
        </div>

        <div id="quest-display">
            <div id="quest-title">임무</div>
            <div id="quest-objective">없음</div>
        </div>

        <!-- 보스 바 컨테이너 -->
        <div id="boss-container">
            <div id="boss-name">BOSS NAME</div>
            <div id="boss-bar-bg">
                <div id="boss-bar-fill"></div>
            </div>
        </div>
        
        <div id="chat-box"></div>
        <div id="horde-warning">⚠️ 경고: 좀비떼가 몰려옵니다!<span id="horde-sub-warning">주변을 경계하세요!</span></div>

        <!-- [NEW] 레벨 및 XP 바 -->
        <div id="level-badge">1</div>
        <div id="xp-bar-container"><div id="xp-fill"></div></div>

        <!-- [NEW] 스코프 UI -->
        <div id="scope-display-container">
            <div id="current-zoom-display"><span class="zoom-label">ZOOM</span> x<span id="zoom-val">1.0</span></div>
            <div class="scope-row">
                <button class="scope-btn locked" id="scope-btn-1">1x</button>
                <button class="scope-btn locked" id="scope-btn-2">2x</button>
                <button class="scope-btn locked" id="scope-btn-4">4x</button>
                <button class="scope-btn locked" id="scope-btn-8">8x</button>
            </div>
            <div style="color:#aaa; font-size:12px; margin-top:2px;" id="scope-hint">스코프가 필요합니다 (상점/루팅)</div>
        </div>

        <div id="trade-modal">
            <h2>상점</h2>
            <div id="trade-list"></div>
            <button id="close-trade-btn">상점 닫기</button>
        </div>

        <!-- [NEW] 스탯창 모달 -->
        <div id="stats-modal">
            <h2>능력치</h2>
            <div id="stat-points-display">남은 포인트: <span id="stat-points-val">0</span></div>
            
            <div class="stat-row">
                <div class="stat-name">체력</div>
                <div class="stat-val" id="vit-val">0</div>
                <button class="stat-btn" onclick="increaseStat('vitality')">+</button>
            </div>
            <div style="font-size:12px; color:#aaa; margin-top:-15px; margin-bottom:10px; text-align:right;">최대 체력 증가 (+10)</div>

            <div class="stat-row">
                <div class="stat-name">근력</div>
                <div class="stat-val" id="str-val">0</div>
                <button class="stat-btn" onclick="increaseStat('strength')">+</button>
            </div>
            <div style="font-size:12px; color:#aaa; margin-top:-15px; margin-bottom:10px; text-align:right;">주먹 공격력 증가 (+2)</div>

            <div class="stat-row">
                <div class="stat-name">민첩 (속도)</div>
                <div class="stat-val" id="agi-val">0</div>
                <button class="stat-btn" onclick="increaseStat('agility')">+</button>
            </div>
            <div style="font-size:12px; color:#aaa; margin-top:-15px; margin-bottom:10px; text-align:right;">이동 속도 증가 (+5%)</div>

            <div class="stat-row">
                <div class="stat-name">내구 (지구력)</div>
                <div class="stat-val" id="end-val">0</div>
                <button class="stat-btn" onclick="increaseStat('endurance')">+</button>
            </div>
            <div style="font-size:12px; color:#aaa; margin-top:-15px; margin-bottom:10px; text-align:right;">최대 스태미나 증가 (+20)</div>

            <div class="stat-row">
                <div class="stat-name">감각 (밝기)</div>
                <div class="stat-val" id="per-val">0</div>
                <button class="stat-btn" onclick="increaseStat('perception')">+</button>
            </div>
            <div style="font-size:12px; color:#aaa; margin-top:-15px; margin-bottom:10px; text-align:right;">야간 시야 밝기 증가</div>

            <button id="close-stats-btn" onclick="closeStatsModal()">닫기 (P)</button>
        </div>

        <div id="ui-overlay">
            <div class="ui-group" id="status-group">
                <div class="status-row">
                    <div class="status-label">체력</div>
                    <div id="health-bar" class="bar-container"><div id="health-fill"></div></div>
                    <div id="health-text" class="status-text">1000 / 1000</div>
                </div>
                <div class="status-row">
                    <div class="status-label">스태미나</div>
                    <div id="stamina-bar" class="bar-container"><div id="stamina-fill"></div></div>
                    <div id="stamina-text" class="status-text">100 / 100</div>
                </div>
                <div class="status-row" id="vehicle-status-row">
                    <div class="status-label">차량 내구도</div>
                    <div id="vehicle-health-bar" class="bar-container"><div id="vehicle-health-fill"></div></div>
                    <div id="vehicle-health-text" class="status-text">5000 / 5000</div>
                </div>
            </div>
            
            <div class="ui-group" id="ammo-container">
                <div id="ammo-display-group">
                    <div id="ammo-display"><span id="current-ammo">0</span> / <span id="ammo-total">0</span></div>
                </div>
                <div id="weapon-name">맨손</div>
                <div id="reload-prompt">[R] 재장전 필요</div>
            </div>
            
            <div id="interaction-prompt">
                <span id="interaction-key">F</span>
                <span id="interaction-item-name">아이템</span>
                <span id="interaction-action">줍기</span>
            </div>
        </div>

        <div id="game-over-screen">
            <div id="game-over-text">GAME OVER</div>
            <button id="restart-button">다시 시작</button>
        </div>
        
        <!-- [NEW] 엔딩 화면 -->
        <div id="ending-screen">
            <div id="ending-title">탈출 성공</div>
            <div id="ending-subtitle">이 구역의 좀비를 대부분 소탕했습니다!</div>
            <div id="ending-stats">
                <div>처치한 좀비: <span id="end-kill-count">0</span></div>
                <div>획득한 몰록: <span id="end-moloch-count">0</span></div>
            </div>
            <div id="ending-number">Ending 10</div>
            <button id="restart-button" onclick="location.reload()" style="background:#00aaff; margin-top:20px;">새로운 시작</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let simplex;

        let scene, camera, renderer, clock, playerGun;
        let muzzle; 
        let raycaster = new THREE.Raycaster();
        
        let objects = [], structures = [], npcs = [], items = [], rangedEnemies = [], zombies = [], bullets = [], debrisParticles = [], vehicles = [], stairTriggers = [], foliage = [], bosses = [], hazardZones = [];
        let portals = [], flares = []; 
        let lavaPlanes = []; 
        
        // [OPTIMIZATION] 재사용 벡터/박스 (GC 감소)
        let tempVec = new THREE.Vector3();
        let tempBox = new THREE.Box3();
        let tempEuler = new THREE.Euler();
        let dummyMatrix = new THREE.Matrix4();
        
        // [OPTIMIZATION] 청크별 오브젝트 맵 (충돌 검사 최적화)
        let chunkStaticObjects = new Map(); // Key: "x,z", Value: [Object3D, ...]

        let sunMesh, moonMesh;

        let sharedTrunkGeo, sharedTrunkMat;
        let sharedLeafGeo, sharedLeafMat;
        let sharedRockGeo, sharedRockMat;
        let sharedBulletGeo, sharedBulletMat;
        
        // [NEW] 오크 군락 최적화를 위한 공유 메테리얼 및 지오메트리
        let sharedOrcWallMat, sharedOrcLogMat, sharedOrcRoofMat1, sharedOrcRoofMat2, sharedOrcTuskMat, sharedOrcBannerMat;
        let sharedOrcWallGeo, sharedOrcLogGeo, sharedOrcRoofGeo1, sharedOrcRoofGeo2, sharedOrcDoorGeo, sharedOrcTuskGeo, sharedOrcPoleGeo, sharedOrcBannerGeo;
        
        let sharedBoxGeo, sharedConeGeo, sharedCityMatGray, sharedCityMatBrown, sharedRoofMat;

        const dummy = new THREE.Object3D(); 
        const invisibleMat = new THREE.MeshBasicMaterial({ visible: false }); 

        let gameTime = 60; 
        const GAME_DAY_DURATION = 240; 
        
        let isPointerLocked = false, isNight = false, sun, isGameOver = false;
        let isAiming = false;
        
        // [NEW] 줌 시스템 변수 & 업그레이드
        const SCOPE_LEVELS = [1, 2, 4, 8];
        let currentScopeIndex = 0; // 현재 적용중인 스코프 인덱스
        let unlockedScopeIndex = -1; // 해금된 최대 스코프 인덱스 (-1: 없음/아이언사이트, 0: 1x, 1: 2x, 2: 4x, 3: 8x)
        let currentZoomLevel = 1.0;
        let zoomClickCount = 0; 
        const BASE_FOV = 75;

        let playerInVehicle = null; 
        let vehicleSteering = 0; 
        let vehicleAcceleration = 0; 
        
        let interactableObject = null;
        let isTrading = false;
        
        let ammoPrices = {};
        let weaponPrices = {};

        const CHUNK_SIZE = 200;
        const RENDER_DISTANCE = 1;
        const generatedChunks = new Set();
        
        let currentPlayerChunkKey = "";
        let frameCount = 0;
        const COLLISION_CHECK_DISTANCE_SQ = 50 * 50; 
        const BULLET_CHECK_DISTANCE_SQ = 50 * 50;
        const ACTIVE_RADIUS = 230;
        const ACTIVE_RADIUS_SQ = ACTIVE_RADIUS * ACTIVE_RADIUS;
        const SAFE_ZONE_RADIUS = 200; 
        const LAVA_LEVEL = 5.0; 
        
        let hasLeftSafeZone = 0;

        let gameStats = { zombieKills: 0, roadKills: 0, totalMolochEarned: 0 };

        const achievements = [
            { id: 'hunter', title: '초보 사냥꾼', desc: '좀비 5마리 처치', condition: () => gameStats.zombieKills >= 5, reward: 300, unlocked: false, claimed: false },
            { id: 'rich', title: '자본주의의 맛', desc: '1000 몰록 보유', condition: () => gameState.moloch >= 1000, reward: 500, unlocked: false, claimed: false },
            { id: 'roadwarrior', title: '로드킬 마스터', desc: '차량으로 적 3마리 처치', condition: () => gameStats.roadKills >= 3, reward: 400, unlocked: false, claimed: false }
        ];

        // [MODIFIED] 첫 퀘스트 보상을 10몰록으로 변경
        let questState = { status: 1, type: 'talk_survivor', targetAmount: 1, currentAmount: 0, rewardMoloch: 10 };
        
        const WEAPON_DATABASE = {
            "M416": { name: "M416", type: "AR", ammoType: "5.56mm", damage: 41, fireRate: 90, magSize: 30, bulletSpeed: 880, reloadTime: 2500, model: createMachineGunModel, effectiveRange: 60, maxRange: 450, minDamageMultiplier: 0.4 },
            "AKM": { name: "AKM", type: "AR", ammoType: "7.62mm", damage: 47, fireRate: 100, magSize: 30, bulletSpeed: 715, reloadTime: 2800, model: createMachineGunModel, effectiveRange: 70, maxRange: 380, minDamageMultiplier: 0.4 },
            "Beryl_M762": { name: "Beryl M762", type: "AR", ammoType: "7.62mm", damage: 44, fireRate: 75, magSize: 30, bulletSpeed: 715, reloadTime: 3000, model: createMachineGunModel, effectiveRange: 60, maxRange: 380, minDamageMultiplier: 0.4 },
            "SCAR-L": { name: "SCAR-L", type: "AR", ammoType: "5.56mm", damage: 41, fireRate: 95, magSize: 30, bulletSpeed: 870, reloadTime: 2600, model: createMachineGunModel, effectiveRange: 60, maxRange: 450, minDamageMultiplier: 0.4 },
            "SKS": { name: "SKS (DMR)", type: "DMR", ammoType: "7.62mm", damage: 53, fireRate: 300, magSize: 10, bulletSpeed: 800, reloadTime: 2900, model: createSniperModel, effectiveRange: 100, maxRange: 500, minDamageMultiplier: 0.7 },
            "Kar98k": { name: "Kar98k (저격총)", type: "SR", ammoType: "7.62mm", damage: 103, fireRate: 1900, magSize: 5, bulletSpeed: 760, reloadTime: 2000, model: createSniperModel, effectiveRange: 120, maxRange: 600, minDamageMultiplier: 0.9 },
            "Vector": { name: "Vector (SMG)", type: "SMG", ammoType: "9mm", damage: 31, fireRate: 50, magSize: 19, bulletSpeed: 350, reloadTime: 2000, model: createPistolModel, effectiveRange: 30, maxRange: 200, minDamageMultiplier: 0.2 },
            "UMP45": { name: "UMP45 (SMG)", type: "SMG", ammoType: ".45 ACP", damage: 41, fireRate: 90, magSize: 25, bulletSpeed: 390, reloadTime: 2200, model: createPistolModel, effectiveRange: 40, maxRange: 250, minDamageMultiplier: 0.25 },
            "S1897": { name: "S1897 (샷건)", type: "SG", ammoType: "12 Gauge", damage: 15, pellets: 9, spread: 0.1, fireRate: 800, magSize: 5, bulletSpeed: 360, reloadTime: 3000, model: createSniperModel, effectiveRange: 10, maxRange: 50, minDamageMultiplier: 0.05 },
            "M249": { name: "M249 (기관총)", type: "LMG", ammoType: "5.56mm", damage: 40, fireRate: 80, magSize: 100, bulletSpeed: 915, reloadTime: 4500, model: createMachineGunModel, effectiveRange: 80, maxRange: 480, minDamageMultiplier: 0.5 },
            "P1911": { name: "P1911 (권총)", type: "Pistol", ammoType: ".45 ACP", damage: 35, fireRate: 400, magSize: 7, bulletSpeed: 250, reloadTime: 1500, model: createPistolModel, effectiveRange: 25, maxRange: 150, minDamageMultiplier: 0.2 },
            "FlashGun": { name: "섬광총", type: "Special", ammoType: "Flare", damage: 0, fireRate: 1000, magSize: 1, bulletSpeed: 400, reloadTime: 2000, model: createPistolModel, effectiveRange: 500, maxRange: 1000, minDamageMultiplier: 0 },
            "Fist": { name: "맨손", type: "Melee", damage: 5, fireRate: 500, range: 5.0, model: () => { const fistMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.6), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 })); fistMesh.position.set(0, 0, -0.3); const group = new THREE.Group(); group.add(fistMesh); const dummyMuzzle = new THREE.Object3D(); dummyMuzzle.name = 'muzzle'; dummyMuzzle.position.set(0, 0, -0.4); group.add(dummyMuzzle); group.userData = { isAnimating: false, type: 'Melee' }; return group; } }
        };

        function calculateEconomy() {
            const ammoDamageSums = {}; const ammoCounts = {};
            for (const key in WEAPON_DATABASE) {
                const weapon = WEAPON_DATABASE[key];
                if (!weapon.ammoType) continue;
                const damage = weapon.damage * (weapon.pellets || 1);
                if (!ammoDamageSums[weapon.ammoType]) { ammoDamageSums[weapon.ammoType] = 0; ammoCounts[weapon.ammoType] = 0; }
                ammoDamageSums[weapon.ammoType] += damage; ammoCounts[weapon.ammoType]++;
            }
            for (const ammoType in ammoDamageSums) { const avgDamage = ammoDamageSums[ammoType] / ammoCounts[ammoType]; ammoPrices[ammoType] = Math.floor(avgDamage / 3); }
            for (const key in WEAPON_DATABASE) { const weapon = WEAPON_DATABASE[key]; const maxDamage = weapon.damage * (weapon.pellets || 1); weaponPrices[key] = Math.floor(maxDamage * (2 / 3)); if (weapon.type === 'Special') weaponPrices[key] = 500; }
            weaponPrices["Fist"] = 0; if(!ammoPrices["Flare"]) ammoPrices["Flare"] = 10;
        }

        const BASE_PLAYER_HEALTH = 1000;
        const BASE_PLAYER_STAMINA = 100;
        let playerStamina = 100; 
        const STAMINA_RECOVERY_RATE = 1.1; const STAMINA_DRAIN_RATE = 15; const JUMP_STAMINA_COST = 15; const STAMINA_THRESHOLD = 5;

        let gameState = {
            health: BASE_PLAYER_HEALTH, moloch: 0, 
            ammoInventory: { "5.56mm": 60, "7.62mm": 60, "9mm": 0, ".45 ACP": 14, "12 Gauge": 10, ".300": 0, "Flare": 5 },
            weapons: [ { key: "Fist" }, { key: "P1911", magAmmo: 7 }, { key: "FlashGun", magAmmo: 1 } ],
            currentWeaponIndex: 0,
            position: new THREE.Vector3(0, 1.8, 0), rotation: new THREE.Vector2(0, 0), velocityY: 0, onGround: true, lastShotTime: 0, isReloading: false, inHighrise: false,
            lastHordeTime: -300, hordeCooldown: 240, hordeActive: false,
            stats: { vitality: 0, strength: 0, agility: 0, endurance: 0, perception: 0 },
            statPoints: 0,
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            isEnding: false // [NEW] 엔딩 진행 상태
        };

        function getMaxHealth() { return BASE_PLAYER_HEALTH + (gameState.stats.vitality * 10); }
        function getMaxStamina() { return BASE_PLAYER_STAMINA + (gameState.stats.endurance * 20); }
        function getMoveSpeed() { return 10 * (1 + gameState.stats.agility * 0.05); }

        function checkLevelUp() {
            if (gameState.xp >= gameState.xpToNextLevel) {
                gameState.xp -= gameState.xpToNextLevel;
                gameState.level++;
                gameState.statPoints++; 
                gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);
                gameState.health = getMaxHealth();
                playerStamina = getMaxStamina();
                showChat('시스템', `레벨 업! 현재 레벨: ${gameState.level} (스탯 포인트 +1)`);
                checkLevelUp();
            }
            updateUI();
        }

        function gainXP(amount) {
            gameState.xp += amount;
            checkLevelUp();
        }

        let isStatsOpen = false;
        function toggleStatsModal() {
            if (isTrading) return;
            isStatsOpen = !isStatsOpen;
            const modal = document.getElementById('stats-modal');
            if (isStatsOpen) {
                document.exitPointerLock();
                modal.style.display = 'flex';
                updateStatsUI();
            } else {
                modal.style.display = 'none';
                document.body.requestPointerLock();
            }
        }
        function closeStatsModal() {
            isStatsOpen = false;
            document.getElementById('stats-modal').style.display = 'none';
            document.body.requestPointerLock();
        }
        function updateStatsUI() {
            document.getElementById('stat-points-val').textContent = gameState.statPoints;
            document.getElementById('vit-val').textContent = gameState.stats.vitality;
            document.getElementById('str-val').textContent = gameState.stats.strength;
            document.getElementById('agi-val').textContent = gameState.stats.agility;
            document.getElementById('end-val').textContent = gameState.stats.endurance;
            document.getElementById('per-val').textContent = gameState.stats.perception;
            const btns = document.querySelectorAll('.stat-btn');
            btns.forEach(btn => {
                btn.disabled = gameState.statPoints <= 0;
            });
        }
        function increaseStat(stat) {
            if (gameState.statPoints > 0) {
                gameState.stats[stat]++;
                gameState.statPoints--;
                if (stat === 'vitality') gameState.health += 10;
                if (stat === 'endurance') playerStamina += 20;
                updateStatsUI();
                updateUI();
            }
        }
        
        // [NEW] 스코프 시스템 함수
        function setScopeLevel(index) {
            if (index < 0) index = 0;
            if (index >= SCOPE_LEVELS.length) index = 0;
            currentScopeIndex = index;
            // 스코프를 바꾸면 줌 레벨 초기화 (1배율로)
            currentZoomLevel = 1.0;
            updateScopeUI();
            
            if (!isAiming) {
                camera.fov = BASE_FOV;
                camera.updateProjectionMatrix();
            }
        }
        
        function cycleScope() {
            // [수정] 해금된 스코프 레벨까지만 순환
            if (unlockedScopeIndex === -1) {
                showChat('시스템', '장착된 스코프가 없습니다.');
                return;
            }
            let nextIndex = currentScopeIndex + 1;
            if (nextIndex > unlockedScopeIndex) nextIndex = 0;
            setScopeLevel(nextIndex);
            showChat('시스템', `스코프 교체: ${SCOPE_LEVELS[currentScopeIndex]}배율`);
        }

        function updateScopeUI() {
            document.querySelectorAll('.scope-btn').forEach((btn, idx) => {
                if (idx > unlockedScopeIndex) {
                    btn.classList.add('locked');
                    btn.classList.remove('active');
                } else {
                    btn.classList.remove('locked');
                    // [수정] 줌 상태에 따라 버튼 활성화 표시
                    if (isAiming && SCOPE_LEVELS[idx] === currentZoomLevel) btn.classList.add('active');
                    else btn.classList.remove('active');
                }
            });
            
            const hint = document.getElementById('scope-hint');
            if (unlockedScopeIndex === -1) {
                hint.textContent = '스코프 없음 (우클릭: 아이언사이트)';
                document.getElementById('zoom-val').textContent = "1.2 (Iron Sight)";
            } else {
                hint.textContent = '[T] 배율 변경 / 조준 중 휠: 미세조절';
                document.getElementById('zoom-val').textContent = currentZoomLevel.toFixed(1);
            }
        }

        let controls = { moveForward: false, moveBackward: false, moveLeft: false, moveRight: false, sprint: false, jump: false };

        class Portal extends THREE.Object3D { 
            constructor(entrancePos, exitPos, buildingId) { super(); this.portalId = `portal_${Date.now()}_${Math.random()}`; this.entrance = entrancePos.clone(); this.exit = exitPos.clone(); this.buildingId = buildingId; this.activationRadius = 1.5; this.cooldownTime = 500; this.lastUsedTime = new Map(); this.isActive = true; }
            canUse(entityId, currentTime) { if (!this.isActive) return false; const lastUsed = this.lastUsedTime.get(entityId) || 0; return (currentTime - lastUsed) > this.cooldownTime; }
            use(entityId, currentTime) { this.lastUsedTime.set(entityId, currentTime); }
        }
        function createPortal(entrancePos, exitPos, buildingId) { const portal = new Portal(entrancePos, exitPos, buildingId); portals.push(portal); return portal; }

        function init() { 
            if (typeof THREE !== 'undefined' && typeof SimplexNoise !== 'undefined') {
                simplex = new SimplexNoise(); 
                sharedTrunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 8.5, 8); sharedTrunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                sharedLeafGeo = new THREE.SphereGeometry(4, 8, 6); sharedLeafMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                sharedRockGeo = new THREE.DodecahedronGeometry(1); sharedRockMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
                sharedBoxGeo = new THREE.BoxGeometry(1, 1, 1); sharedConeGeo = new THREE.ConeGeometry(8, 3, 4); 
                sharedCityMatGray = new THREE.MeshLambertMaterial({ color: 0xcccccc }); sharedCityMatBrown = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); sharedRoofMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                sharedBulletGeo = new THREE.SphereGeometry(0.08, 4, 4); sharedBulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); 

                // [OPTIMIZATION] 오크 관련 공유 자원 초기화
                sharedOrcWallMat = new THREE.MeshLambertMaterial({ color: 0x3e2723, flatShading: true });
                sharedOrcLogMat = new THREE.MeshLambertMaterial({ color: 0x1a1110, flatShading: true });
                sharedOrcRoofMat1 = new THREE.MeshLambertMaterial({ color: 0x556B2F, flatShading: true });
                sharedOrcRoofMat2 = new THREE.MeshLambertMaterial({ color: 0x4a5d23, flatShading: true });
                sharedOrcTuskMat = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });
                sharedOrcBannerMat = new THREE.MeshLambertMaterial({ color: 0x8b0000 });

                sharedOrcWallGeo = new THREE.CylinderGeometry(4, 4.8, 3.8, 7);
                sharedOrcLogGeo = new THREE.CylinderGeometry(0.25, 0.35, 4.5, 4); // 세그먼트 감소 (5->4)
                sharedOrcRoofGeo1 = new THREE.ConeGeometry(6.0, 2.5, 7);
                sharedOrcRoofGeo2 = new THREE.ConeGeometry(5.0, 3.0, 7);
                sharedOrcDoorGeo = new THREE.BoxGeometry(2.5, 3.5, 2);
                sharedOrcTuskGeo = new THREE.ConeGeometry(0.3, 3.5, 5); // 세그먼트 감소
                sharedOrcPoleGeo = new THREE.CylinderGeometry(0.1, 0.15, 6, 4);
                sharedOrcBannerGeo = new THREE.BoxGeometry(2, 1.5, 0.1);

                calculateEconomy(); startLoading(); 
            } else { showError('라이브러리 로드 실패'); }
        }

        function checkAchievements() { achievements.forEach(ach => { if (!ach.unlocked && ach.condition()) { ach.unlocked = true; showAchievementPopup(ach); } }); }
        function showAchievementPopup(ach) { const popup = document.getElementById('achievement-popup'); document.getElementById('achievement-title').textContent = ach.title; document.getElementById('achievement-desc').textContent = ach.desc; popup.style.display = 'block'; setTimeout(() => { popup.style.transform = 'translateX(0)'; }, 50); setTimeout(() => { popup.style.transform = 'translateX(100%)'; setTimeout(() => { popup.style.display = 'none'; }, 500); }, 10000); }

        function startLoading() {
            const tips = ["P키를 눌러 능력치를 찍어보세요.", "T키를 눌러 스코프 배율 한계를 변경할 수 있습니다.", "우클릭 조준 중 마우스 휠을 굴려 줌을 조절하세요.", "레벨업 시 체력과 스태미나가 모두 회복됩니다.", "F 키로 차량에 탑승하거나 아이템을 주울 수 있습니다."]; 
            let tipIndex = 0; const tipElement = document.getElementById('loading-tips'); tipElement.textContent = `게임 팁: ${tips[tipIndex]}`;
            const tipInterval = setInterval(() => { tipIndex = (tipIndex + 1) % tips.length; tipElement.textContent = `게임 팁: ${tips[tipIndex]}`; }, 3000);
            let progress = 0;
            const loadingInterval = setInterval(() => { progress += 10; document.getElementById('loading-fill').style.width = `${progress}%`; document.getElementById('loading-progress').textContent = `월드 생성 중... ${progress}%`; if (progress >= 100) { clearInterval(loadingInterval); clearInterval(tipInterval); setTimeout(() => { try { startGame(); } catch (e) { console.error('게임 시작 실패:', e); showError('게임을 시작할 수 없습니다.'); } }, 500); } }, 250);
        }

        // [MODIFIED] 게임 시작 시 updateQuestUI() 호출 추가
        function startGame() { createScene(); switchWeapon(0); const startY = getTerrainHeight(gameState.position.x, gameState.position.z); gameState.position.y = startY + 1.8; updateWorldChunks(); currentPlayerChunkKey = `${Math.round(gameState.position.x / CHUNK_SIZE)},${Math.round(gameState.position.z / CHUNK_SIZE)}`; setupControls(); document.getElementById('close-trade-btn').addEventListener('click', closeTradeModal); hideLoading(); animate(); updateScopeUI(); updateQuestUI(); }
        function showError(msg) { document.getElementById('loading-screen').innerHTML = `<div class="loading-text" style="color: #ff6666;">오류</div><div style="color:#fff;margin-top:20px;">${msg}</div>`; }
        function hideLoading() { document.getElementById('loading-screen').style.display = 'none'; }

        function createScene() {
            // [FIX] 기존 렌더러 및 캔버스 정리 (Context Loss 방지)
            const container = document.getElementById('game-container');
            if (renderer) {
                renderer.dispose();
                // 이미 DOM에 있다면 제거
                if (renderer.domElement && renderer.domElement.parentNode === container) {
                    container.removeChild(renderer.domElement);
                }
                renderer = null;
            }
            // 혹시 모를 잔여 캔버스 강제 제거
            const oldCanvas = container.querySelector('canvas');
            if (oldCanvas) container.removeChild(oldCanvas);

            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 1, 200); 
            camera = new THREE.PerspectiveCamera(BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 3000); camera.position.copy(gameState.position); scene.add(camera);
            
            // [FIX] WebGL 생성 실패 시 예외 처리 및 Fallback
            try {
                // 1차 시도: 고성능 옵션
                renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            } catch (e1) {
                console.warn('WebGL initialization failed, retrying with default settings...', e1);
                try {
                    // 2차 시도: 기본 옵션 (안티앨리어싱 끔)
                    renderer = new THREE.WebGLRenderer({ antialias: false });
                } catch (e2) {
                    console.error('Critical WebGL Error:', e2);
                    showError('WebGL을 초기화할 수 없습니다. (Context Creation Error)');
                    return;
                }
            }

            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2)); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFShadowMap; container.appendChild(renderer.domElement);
            clock = new THREE.Clock(); const ambientLight = new THREE.AmbientLight(0x404040, 0.6); scene.ambientLight = ambientLight; scene.add(ambientLight);
            sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 50, 50); sun.castShadow = true; sun.shadow.mapSize.width = 1024; sun.shadow.mapSize.height = 1024; sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 500; const d = 100; sun.shadow.camera.left = -d; sun.shadow.camera.right = d; sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d; scene.add(sun);
            const sunGeo = new THREE.SphereGeometry(150, 64, 64); const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, fog: false }); sunMesh = new THREE.Mesh(sunGeo, sunMat); scene.add(sunMesh);
            const moonGeo = new THREE.SphereGeometry(100, 64, 64); const moonMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222, roughness: 0.8, fog: false }); moonMesh = new THREE.Mesh(moonGeo, moonMat); scene.add(moonMesh);
        }
        
        function createPistolModel() { const gun = new THREE.Group(); const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 }); gun.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.3), bodyMaterial)); const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8), bodyMaterial); barrel.position.set(0, 0, -0.275); barrel.rotation.x = Math.PI / 2; gun.add(barrel); const gunMuzzle = new THREE.Object3D(); gunMuzzle.name = 'muzzle'; gunMuzzle.position.set(0, 0, -0.4); gun.add(gunMuzzle); return gun; }
        function createMachineGunModel() { const gun = new THREE.Group(); const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 }); gun.add(new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.8), bodyMaterial)); const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8), bodyMaterial); barrel.position.set(0, 0, -0.7); barrel.rotation.x = Math.PI / 2; gun.add(barrel); const gunMuzzle = new THREE.Object3D(); gunMuzzle.name = 'muzzle'; gunMuzzle.position.set(0, 0, -1.0); gun.add(gunMuzzle); return gun; }
        function createSniperModel() { const gun = new THREE.Group(); const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.4 }); gun.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 1.2), bodyMaterial)); const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.9, 8), bodyMaterial); barrel.position.set(0, 0, -1.05); barrel.rotation.x = Math.PI / 2; gun.add(barrel); const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.3, 8), bodyMaterial); scope.position.set(0, 0.15, -0.4); scope.rotation.x = Math.PI / 2; gun.add(scope); const gunMuzzle = new THREE.Object3D(); gunMuzzle.name = 'muzzle'; gunMuzzle.position.set(0, 0, -1.5); gun.add(gunMuzzle); return gun; }
        
        function switchWeapon(index) { if (index >= gameState.weapons.length) index = 0; if (index < 0) index = gameState.weapons.length - 1; gameState.currentWeaponIndex = index; if (playerGun) camera.remove(playerGun); const weaponObj = gameState.weapons[index]; const weaponData = WEAPON_DATABASE[weaponObj.key]; playerGun = weaponData.model(); playerGun.position.set(0.4, -0.3, -0.8); playerGun.rotation.set(0, -0.1, 0); camera.add(playerGun); muzzle = playerGun.getObjectByName('muzzle'); updateUI(); }
        
        function updateWorldChunks() { const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position; const playerChunkX = Math.round(playerPos.x / CHUNK_SIZE); const playerChunkZ = Math.round(playerPos.z / CHUNK_SIZE); for (let x = playerChunkX - RENDER_DISTANCE; x <= playerChunkX + RENDER_DISTANCE; x++) { for (let z = playerChunkZ - RENDER_DISTANCE; z <= playerChunkZ + RENDER_DISTANCE; z++) { const chunkKey = `${x},${z}`; if (!generatedChunks.has(chunkKey)) { generateChunk(x, z); generatedChunks.add(chunkKey); } } } }
        
        function getBiome(x, z) { 
            const scale = 3000; 
            const value = simplex.noise2D(x / scale, z / scale); 
            if (value > 0.3) { 
                const volcanoChance = simplex.noise2D(x / 1000 + 100, z / 1000 + 100);
                if (volcanoChance > 0.6) return 'volcano';
                return 'mountain'; 
            }
            if (value > -0.2) return 'plain'; 
            if (value > -0.6) return 'forest'; 
            return 'city'; 
        }
        
        function getTerrainHeight(x, z) {
            const scale = 3000;
            const biomeValue = simplex.noise2D(x / scale, z / scale);
            let y = simplex.noise2D(x / 500, z / 500) * 15;
            y += simplex.noise2D(x / 100, z / 100) * 3; 

            if (biomeValue > 0.2) {
                let blend = (biomeValue - 0.2) / 0.6;
                if (blend > 1) blend = 1;
                blend = blend * blend * (3 - 2 * blend); 
                let mountainShape = simplex.noise2D(x / 300, z / 300);
                if (mountainShape < 0) mountainShape = 0; 
                y += mountainShape * 120 * blend;
                y += simplex.noise2D(x / 50, z / 50) * 10 * blend;

                const volcanoChance = simplex.noise2D(x / 1000 + 100, z / 1000 + 100);
                if (volcanoChance > 0.6) {
                    let vBlend = (volcanoChance - 0.6) / 0.4;
                    if (vBlend > 1) vBlend = 1;
                    vBlend = vBlend * vBlend * (3 - 2 * vBlend);
                    y += Math.abs(simplex.noise2D(x / 150, z / 150)) * 80 * vBlend;
                }
            }

            if (biomeValue < -0.4) {
                let blend = (-0.4 - biomeValue) / 0.3; 
                if (blend > 1) blend = 1;
                blend = blend * blend * (3 - 2 * blend);
                y = (1 - blend) * y + (blend * 5.0);
            }
            return y;
        }

        // [NEW] 특정 위치의 용암 높이를 계산하는 함수
        function getLavaHeight(x, z) {
            const tHeight = getTerrainHeight(x, z);
            const biome = getBiome(x, z);
            
            if (biome === 'volcano') {
                // 1. 웅덩이: 지형이 LAVA_LEVEL보다 낮으면 용암 높이는 LAVA_LEVEL
                if (tHeight < LAVA_LEVEL) return LAVA_LEVEL;
                
                // 2. 흐르는 용암: 노이즈 조건이 맞으면 지형보다 살짝 위에 존재
                const flowNoise = simplex.noise2D(x / 40, z / 40);
                if (flowNoise > 0.3) return tHeight + 0.2;
            }
            
            // 용암이 없는 곳은 지하 깊숙한 곳으로 처리
            return -1000;
        }

        function spawnItem(data, x, y, z) {
            let mesh;
            if (data.type === 'weapon') {
                mesh = WEAPON_DATABASE[data.name].model();
                mesh.scale.set(0.5, 0.5, 0.5);
                mesh.rotation.z = Math.PI / 4;
            } else if (data.type === 'scope') {
                // 스코프 아이템 모델
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.3, 8), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                mesh.rotation.x = Math.PI / 2;
                const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.02, 8), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                lens.position.y = 0.16;
                mesh.add(lens);
            } else {
                let color = 0xffffff;
                let geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                if (data.name === '탄약') { color = 0x556B2F; geo = new THREE.BoxGeometry(0.3, 0.2, 0.4); }
                if (data.name === '의료키트') { color = 0xffffff; geo = new THREE.BoxGeometry(0.5, 0.3, 0.4); }
                if (data.name === '에너지드링크') { color = 0x00ffff; geo = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8); }
                if (data.name === '음식') { color = 0xffa500; }
                mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color }));
                if (data.name === '의료키트') {
                    const v = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.32, 0.1), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    const h = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.32), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    mesh.add(v); v.rotation.z = Math.PI/2; mesh.add(h); h.rotation.y = Math.PI/2;
                }
            }
            mesh.position.set(x, y, z); 
            // [수정] 아이템 그림자 제거
            mesh.castShadow = false; 
            
            mesh.userData = { ...data, isGrounded: false, velocityY: 0 };
            scene.add(mesh); items.push(mesh);
        }

        function createRandomLoot(x, z, y) {
            const rand = Math.random();
            if (rand < 0.4) {
                const ammoTypes = Object.keys(gameState.ammoInventory);
                const type = ammoTypes[Math.floor(Math.random() * ammoTypes.length)];
                if (type === 'Flare') return;
                spawnItem({ type: 'item', name: '탄약', subtype: type, amount: 10 + Math.floor(Math.random() * 20) }, x, y, z);
            } else if (rand < 0.55) {
                const cons = ['의료키트', '에너지드링크', '음식'];
                spawnItem({ type: 'item', name: cons[Math.floor(Math.random() * cons.length)], amount: 1 }, x, y, z);
            } else if (rand < 0.65) {
                const keys = Object.keys(WEAPON_DATABASE).filter(k => k !== 'Fist' && k !== 'FlashGun');
                const key = keys[Math.floor(Math.random() * keys.length)];
                spawnItem({ type: 'weapon', name: key }, x, y, z);
            } else if (rand < 0.75) {
                // [NEW] 스코프 드랍
                const scopeRoll = Math.random();
                let level = 0; // 1x
                if (scopeRoll > 0.9) level = 3; // 8x
                else if (scopeRoll > 0.7) level = 2; // 4x
                else if (scopeRoll > 0.4) level = 1; // 2x
                
                spawnItem({ type: 'scope', level: level, name: `${SCOPE_LEVELS[level]}배율 스코프` }, x, y, z);
            }
        }

        function createBuildingLoot(x, y, z) {
            if (Math.random() < 0.7) createRandomLoot(x, z, y);
        }

        function createWorldTree(x, z, yBase) {
            const trunkGeo = new THREE.CylinderGeometry(4, 6, 40, 16); const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a2e16 }); const trunk = new THREE.Mesh(trunkGeo, trunkMat); trunk.position.set(x, yBase + 20, z); trunk.castShadow = false; trunk.receiveShadow = true; trunk.userData = { health: 999999, maxHealth: 999999, type: 'object', originalColor: trunkMat.color.clone() }; scene.add(trunk); objects.push(trunk);
            const leavesGeo = new THREE.SphereGeometry(25, 16, 16); const leavesMat = new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x004400, emissiveIntensity: 0.2 }); const leaves = new THREE.Mesh(leavesGeo, leavesMat); leaves.position.set(x, yBase + 50, z); leaves.castShadow = false; leaves.userData = { health: 999999, maxHealth: 999999, type: 'object', originalColor: leavesMat.color.clone() }; scene.add(leaves); foliage.push(leaves);
            const light = new THREE.PointLight(0x00ff00, 2, 60); light.position.set(x, yBase + 10, z); scene.add(light);
        }

        function collectTreeData(x, z, yBase, trunkMatrices, leafMatrices, trunkProxies, leafProxies) {
            dummy.position.set(x, yBase + 3.75, z); dummy.rotation.set(0, 0, 0); dummy.scale.set(1, 1, 1); dummy.updateMatrix(); trunkMatrices.push(dummy.matrix.clone());
            const trunkProxy = new THREE.Mesh(sharedTrunkGeo, invisibleMat); trunkProxy.position.copy(dummy.position); trunkProxy.visible = true; trunkProxy.userData = { health: 20000, maxHealth: 20000, type: 'object', originalColor: sharedTrunkMat.color.clone() }; scene.add(trunkProxy); objects.push(trunkProxy); trunkProxies.push(trunkProxy);
            dummy.position.set(x, yBase + 10, z); dummy.rotation.set(0, 0, 0); dummy.scale.set(1, 1, 1); dummy.updateMatrix(); leafMatrices.push(dummy.matrix.clone());
            const leafProxy = new THREE.Mesh(sharedLeafGeo, invisibleMat); leafProxy.position.copy(dummy.position); leafProxy.visible = true; leafProxy.userData = { health: 10000, maxHealth: 10000, type: 'object', originalColor: sharedLeafMat.color.clone() }; scene.add(leafProxy); objects.push(leafProxy); leafProxies.push(leafProxy);
        }

        function collectRockData(x, z, yBase, rockMatrices, rockProxies) {
            const radius = Math.random() * 2 + 1; 
            dummy.position.set(x, yBase + 1, z); dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI); dummy.scale.set(radius, radius, radius); dummy.updateMatrix(); rockMatrices.push(dummy.matrix.clone());
            const rockProxy = new THREE.Mesh(sharedRockGeo, invisibleMat); rockProxy.position.copy(dummy.position); 
            rockProxy.scale.set(radius, radius, radius); 
            rockProxy.visible = true; rockProxy.userData = { health: 30000, maxHealth: 30000, type: 'object', isRock: true, originalColor: sharedRockMat.color.clone() }; scene.add(rockProxy); objects.push(rockProxy); rockProxies.push(rockProxy);
        }

        // [OPTIMIZATION] 청크 생성 시 정적 오브젝트 등록
        function registerChunkObject(chunkKey, obj) {
            if (!chunkStaticObjects.has(chunkKey)) chunkStaticObjects.set(chunkKey, []);
            chunkStaticObjects.get(chunkKey).push(obj);
        }

        function createChunkInstancedMeshes(matrices, geometry, material, proxies, chunkKey) {
            if (matrices.length === 0) return; const mesh = new THREE.InstancedMesh(geometry, material, matrices.length); 
            // [수정] 모든 인스턴스 메쉬(건물, 나무, 돌 등) 그림자 제거
            mesh.castShadow = false; 
            
            mesh.receiveShadow = true;
            for (let i = 0; i < matrices.length; i++) { 
                mesh.setMatrixAt(i, matrices[i]); const proxy = proxies[i]; proxy.userData.instancedMesh = mesh; proxy.userData.instanceId = i; 
                registerChunkObject(chunkKey, proxy); 
            } 
            mesh.instanceMatrix.needsUpdate = true; scene.add(mesh);
        }

        function generateChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`; // [OPTIMIZATION] 키 생성
            const chunkOriginX = chunkX * CHUNK_SIZE; const chunkOriginZ = chunkZ * CHUNK_SIZE; const centerBiome = getBiome(chunkOriginX, chunkOriginZ); const seed = chunkX * 31 + chunkZ * 17; let rand = (s) => () => (s = Math.sin(s) * 10000, s - Math.floor(s)); let chunkRand = rand(seed); let buildingsInChunk = [];
            let objectDensityMultiplier = 1.0; let buildingChance = 0.1;
            if (centerBiome === 'forest') objectDensityMultiplier = 3.0; else if (centerBiome === 'mountain') objectDensityMultiplier = 0.5; else if (centerBiome === 'volcano') objectDensityMultiplier = 0.1; else if (centerBiome === 'city') { objectDensityMultiplier = 0.2; buildingChance = 0.9; } else if (centerBiome === 'plain') { buildingChance = 0.3; }

            const objectCount = Math.floor((chunkRand() * 10 + 15) * objectDensityMultiplier);
            if (centerBiome === 'city') {
                const cityGridSize = 40; for(let cx = chunkOriginX - CHUNK_SIZE/2; cx < chunkOriginX + CHUNK_SIZE/2; cx += cityGridSize) { for(let cz = chunkOriginZ - CHUNK_SIZE/2; cz < chunkOriginZ + CHUNK_SIZE/2; cz += cityGridSize) { if (chunkRand() > 0.3) { const isHighrise = chunkRand() > 0.4; const size = isHighrise ? { w: 30, d: 30 } : { w: 15, d: 15 }; const y = getTerrainHeight(cx, cz); buildingsInChunk.push({ x: cx + (chunkRand()*10-5), z: cz + (chunkRand()*10-5), y, size, isHighrise }); } } }
            } else if (chunkRand() > (1 - buildingChance)) { for (let i = 0; i < objectCount; i++) { const x = chunkOriginX + (chunkRand() - 0.5) * CHUNK_SIZE; const z = chunkOriginZ + (chunkRand() - 0.5) * CHUNK_SIZE; const type = chunkRand(); if (type > 0.9) { const isHighrise = chunkRand() > 0.8; const size = isHighrise ? { w: 30, d: 40 } : { w: 12, d: 12 }; const y = getTerrainHeight(x, z); buildingsInChunk.push({ x, z, y, size, isHighrise }); } } }
            
            if (centerBiome === 'forest') {
                if ((Math.abs(chunkX * 7 + chunkZ * 13) % 50) === 0) {
                    const wx = chunkOriginX; const wz = chunkOriginZ; const wy = getTerrainHeight(wx, wz); createWorldTree(wx, wz, wy);
                    for(let k=0; k<10; k++) { const tx = wx + (Math.random() - 0.5) * 600; const tz = wz + (Math.random() - 0.5) * 600; const ty = getTerrainHeight(tx, tz); createTroll(tx, tz, ty); }
                    if (chunkRand() > 0.3) { createBoss('witch', wx + 15, wz + 15, wy); }
                }

                if (chunkRand() > 0.9) {
                    const colonySize = Math.floor(chunkRand() * 4) + 1; 
                    createOrcColony(chunkOriginX, chunkOriginZ, chunkRand, colonySize);
                }
            }
            
            const terrainGeo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, 100, 100); 
            const vertices = terrainGeo.attributes.position.array; 
            for (let i = 0, j = 0; i < vertices.length; i += 3, j++) { 
                const wx = vertices[i] + chunkOriginX; 
                const wz = chunkOriginZ - vertices[i + 1]; 
                let wy = getTerrainHeight(wx, wz); 
                vertices[i + 2] = wy; 
            } 
            terrainGeo.computeVertexNormals(); 

            let groundColor = 0x3a5f3a; if (centerBiome === 'mountain') groundColor = 0x5a5a5a; else if (centerBiome === 'forest') groundColor = 0x1a3f1a; else if (centerBiome === 'city') groundColor = 0x222222; else if (centerBiome === 'volcano') groundColor = 0x111111; 
            const ground = new THREE.Mesh(terrainGeo, new THREE.MeshStandardMaterial({ color: groundColor, roughness: 0.9 })); ground.rotation.x = -Math.PI / 2; ground.position.set(chunkOriginX, 0, chunkOriginZ); ground.receiveShadow = true; scene.add(ground); objects.push(ground); structures.push(ground);
            
            // [MODIFIED] 용암 생성 로직 개선 (청크 경계 문제 해결 및 흐르는 효과)
            // 기존: 중심 바이옴이 화산일 때만 평평한 판 생성 -> 변경: 모든 청크에서 버텍스 단위로 검사하여 지형 적응형 용암 생성
            const lavaGeo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, 32, 32);
            const lavaVerts = lavaGeo.attributes.position.array;
            let hasLava = false;

            for (let i = 0; i < lavaVerts.length; i += 3) {
                const wx = lavaVerts[i] + chunkOriginX;
                const wz = chunkOriginZ - lavaVerts[i + 1]; // Plane 회전 고려 (local Y가 world -Z)
                
                const tHeight = getTerrainHeight(wx, wz);
                const biome = getBiome(wx, wz);
                
                let lHeight = -500; // 기본값: 지하로 숨김

                // 화산 지대이거나, 낮은 지대(용암 웅덩이 가능성)
                if (biome === 'volcano') {
                    if (tHeight < LAVA_LEVEL) {
                        // 1. 웅덩이: 지형이 용암 수위보다 낮으면 수위 유지
                        lHeight = LAVA_LEVEL;
                    } else {
                        // 2. 흘러내림: 지형이 높아도 노이즈에 따라 용암 줄기 생성
                        // 흐름 노이즈 생성 (크기 40 정도로 조정)
                        const flowNoise = simplex.noise2D(wx / 40, wz / 40);
                        // 특정 패턴(줄기)에만 용암 배치
                        if (flowNoise > 0.3) {
                            lHeight = tHeight + 0.2; // 지형 바로 위를 덮음
                        } else {
                            lHeight = tHeight - 3.0; // 나머지는 지형 바로 아래로 숨김 (수직 절벽 방지)
                        }
                    }
                } else {
                    // 화산이 아닌 곳은 지형 아래로 숨김
                    lHeight = tHeight - 3.0; 
                }

                // PlaneGeometry는 XY 평면이므로 Z값을 높이로 사용 (회전 전 기준)
                lavaVerts[i + 2] = lHeight;
                
                if (lHeight > -100) hasLava = true;
            }

            lavaGeo.computeVertexNormals();

            if (hasLava) {
                const lavaMat = new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.8, side: THREE.DoubleSide }); 
                const lava = new THREE.Mesh(lavaGeo, lavaMat); 
                lava.rotation.x = -Math.PI / 2; 
                // 높이(Y)는 이미 geometry의 Z값(회전 후 Y)에 반영되었으므로 position.y는 0
                lava.position.set(chunkOriginX, 0, chunkOriginZ); 
                lava.userData = { type: 'lava', isSteppable: true };
                scene.add(lava); lavaPlanes.push(lava); objects.push(lava);
                registerChunkObject(chunkKey, lava);
                
                // 용암 조명은 화산 중심부 근처에만 추가 (성능 최적화)
                if (centerBiome === 'volcano' && Math.random() > 0.5) {
                    const lavaLight = new THREE.PointLight(0xff4400, 1, 80); 
                    lavaLight.position.set(chunkOriginX, LAVA_LEVEL + 5, chunkOriginZ); 
                    lavaLight.castShadow = false; 
                    scene.add(lavaLight); 
                }
            }

            const chunkCityGrayMatrices = []; const chunkCityBrownMatrices = []; const chunkRoofMatrices = []; const chunkCityGrayProxies = []; const chunkCityBrownProxies = []; const chunkRoofProxies = [];
            buildingsInChunk.forEach(b => { if (b.isHighrise) { collectHighriseData(b.x, b.z, b.y, chunkCityGrayMatrices, chunkCityGrayProxies); } else { collectBuildingData(b.x, b.z, b.y, chunkCityBrownMatrices, chunkCityBrownProxies, chunkRoofMatrices, chunkRoofProxies); } });
            createChunkInstancedMeshes(chunkCityGrayMatrices, sharedBoxGeo, sharedCityMatGray, chunkCityGrayProxies, chunkKey); createChunkInstancedMeshes(chunkCityBrownMatrices, sharedBoxGeo, sharedCityMatBrown, chunkCityBrownProxies, chunkKey); createChunkInstancedMeshes(chunkRoofMatrices, sharedConeGeo, sharedRoofMat, chunkRoofProxies, chunkKey);
            const chunkTrunkMatrices = []; const chunkLeafMatrices = []; const chunkRockMatrices = []; const chunkTrunkProxies = []; const chunkLeafProxies = []; const chunkRockProxies = [];
            if (centerBiome !== 'city' && (chunkRand() > 0.3 || centerBiome === 'forest' || centerBiome === 'volcano')) { for (let i = 0; i < objectCount; i++) { const x = chunkOriginX + (chunkRand() - 0.5) * CHUNK_SIZE; const z = chunkOriginZ + (chunkRand() - 0.5) * CHUNK_SIZE; const type = chunkRand(); let inBuildingArea = false; for (const building of buildingsInChunk) { const halfW = building.size.w / 2; const halfD = building.size.d / 2; if (x >= building.x - halfW && x <= building.x + halfW && z >= building.z - halfD && z <= building.z + halfD) { inBuildingArea = true; break; } } if (inBuildingArea) continue; const yBase = getTerrainHeight(x, z); let treeChance = 0.6; if (centerBiome === 'forest') treeChance = 0.9; if (centerBiome === 'mountain') treeChance = 0.2; if (centerBiome === 'volcano') treeChance = 0.05; if (centerBiome === 'volcano' && yBase < LAVA_LEVEL + 1) continue; if (type < treeChance) { collectTreeData(x, z, yBase, chunkTrunkMatrices, chunkLeafMatrices, chunkTrunkProxies, chunkLeafProxies); } else if (type < 0.9 || centerBiome === 'volcano') { collectRockData(x, z, yBase, chunkRockMatrices, chunkRockProxies); } } }
            createChunkInstancedMeshes(chunkTrunkMatrices, sharedTrunkGeo, sharedTrunkMat, chunkTrunkProxies, chunkKey); createChunkInstancedMeshes(chunkLeafMatrices, sharedLeafGeo, sharedLeafMat, chunkLeafProxies, chunkKey); createChunkInstancedMeshes(chunkRockMatrices, sharedRockGeo, sharedRockMat, chunkRockProxies, chunkKey);
            
            if (chunkRand() > 0.5) { 
                const x = chunkOriginX + (chunkRand() - 0.5) * CHUNK_SIZE; const z = chunkOriginZ + (chunkRand() - 0.5) * CHUNK_SIZE; const yBase = getTerrainHeight(x, z); 
                if (centerBiome !== 'volcano' || yBase > LAVA_LEVEL) { createRangedEnemy(x, z, 500 + chunkRand() * 500, yBase); }
                const zombieCount = Math.floor(chunkRand() * 3) + 1; for (let i = 0; i < zombieCount; i++) { const zx = x + (chunkRand() - 0.5) * 10; const zz = z + (chunkRand() - 0.5) * 10; const zy = getTerrainHeight(zx, zz); if (centerBiome !== 'volcano' || zy > LAVA_LEVEL) { createZombie(zx, zz, 500, zy); } }
            }

            if (centerBiome === 'city') {
                const cityDeepNoise = simplex.noise2D(chunkOriginX / 3000, chunkOriginZ / 3000);
                if (cityDeepNoise < -0.8 && chunkRand() > 0.95) {
                    const x = chunkOriginX + (chunkRand() - 0.5) * 20; const z = chunkOriginZ + (chunkRand() - 0.5) * 20; const y = getTerrainHeight(x, z); createBoss('witch', x, z, y);
                }
            }
            if (centerBiome === 'volcano') {
                if (chunkRand() > 0.7) {
                    const x = chunkOriginX + (chunkRand() - 0.5) * 20; const z = chunkOriginZ + (chunkRand() - 0.5) * 20; const y = getTerrainHeight(x, z);
                    if (y > LAVA_LEVEL) { createBoss('fire_demon', x, z, y); }
                }
            }

            if (chunkRand() > 0.93) { const x = chunkOriginX + (chunkRand() - 0.5) * CHUNK_SIZE; const z = chunkOriginZ + (chunkRand() - 0.5) * CHUNK_SIZE; const yBase = getTerrainHeight(x, z); if (centerBiome !== 'volcano' || yBase > LAVA_LEVEL) { createRandomLoot(x, z, yBase + 0.5); } }
            if (chunkRand() > 0.68 && centerBiome !== 'volcano') { const x = chunkOriginX + (chunkRand() - 0.5) * CHUNK_SIZE; const z = chunkOriginZ + (chunkRand() - 0.5) * CHUNK_SIZE; const yBase = getTerrainHeight(x, z); createVehicle(x, z, yBase); }
            if (chunkX === 0 && chunkZ === 0) { const y1 = getTerrainHeight(-20, -20); createNPC(-20, -20, 0x0000ff, '상인', ["무한한 세계에 오신 것을 환영합니다!", "제게 남는 탄약이나 무기를 파시면 몰록(화폐)을 드립니다."], y1); const y2 = getTerrainHeight(25, 15); createNPC(25, 15, 0x00ff00, '생존자', ["지평선 너머엔 무엇이 있을까요?", "항상 주변을 경계하세요.", "조준 중에 마우스 휠을 굴리면 줌을 조절할 수 있습니다."], y2); }
        }
        
        function createOrcColony(centerX, centerZ, randFunc, size) {
            const centerY = getTerrainHeight(centerX, centerZ);
            const radiusSpread = 30 * size; 
            const hutCount = (3 + Math.floor(randFunc() * 2)) * size;
            const warriorCount = (5 + Math.floor(randFunc() * 4)) * size;

            for(let i=0; i<hutCount; i++) {
                const angle = (Math.PI * 2 * randFunc()) + (i * 0.5); const dist = 10 + randFunc() * radiusSpread; const hx = centerX + Math.cos(angle) * dist; const hz = centerZ + Math.sin(angle) * dist; const hy = getTerrainHeight(hx, hz); createOrcHut(hx, hz, hy);
            }
            // 오크 전사 생성 시에도 최적화된 함수 사용 (기존 함수 유지하되 내부 최적화)
            for(let i=0; i<warriorCount; i++) {
                const ox = centerX + (randFunc() - 0.5) * (radiusSpread * 2.5); const oz = centerZ + (randFunc() - 0.5) * (radiusSpread * 2.5); const oy = getTerrainHeight(ox, oz); createOrc(ox, oz, oy, false);
            }
            createOrc(centerX, centerZ, centerY, true);
            if (size >= 3) { createOrc(centerX + 10, centerZ + 10, getTerrainHeight(centerX+10, centerZ+10), true); }
            for(let i=0; i<size; i++) { createRandomLoot(centerX + (randFunc()-0.5)*20, centerZ + (randFunc()-0.5)*20, centerY + 1.0); }
            showChat('시스템', `주변에서 거대한 오크 군락(${size}구역 급)의 기운이 느껴집니다...`);
        }

        function createOrcHut(x, z, yBase) {
            const hutGroup = new THREE.Group();
            
            // [OPTIMIZATION] 공유 지오메트리 & 메테리얼 사용
            const wall = new THREE.Mesh(sharedOrcWallGeo, sharedOrcWallMat); 
            wall.position.y = 1.9; wall.castShadow = false; hutGroup.add(wall);
            
            // 통나무 장식
            for(let i=0; i<7; i++) { 
                const angle = (Math.PI * 2 / 7) * i; 
                const log = new THREE.Mesh(sharedOrcLogGeo, sharedOrcLogMat); 
                log.position.set(Math.cos(angle)*4.5, 2.25, Math.sin(angle)*4.5); 
                log.rotation.z = (Math.random() - 0.5) * 0.3; 
                log.rotation.x = (Math.random() - 0.5) * 0.3; 
                log.castShadow = false; 
                hutGroup.add(log); 
            }

            const roof1 = new THREE.Mesh(sharedOrcRoofGeo1, sharedOrcRoofMat1); roof1.position.y = 4.0; roof1.castShadow = false; hutGroup.add(roof1);
            const roof2 = new THREE.Mesh(sharedOrcRoofGeo2, sharedOrcRoofMat2); roof2.position.y = 5.0; roof2.rotation.y = 0.5; roof2.castShadow = false; hutGroup.add(roof2);
            
            const doorMat = new THREE.MeshBasicMaterial({ color: 0x050505 }); // 문은 간단해서 그냥 생성
            const door = new THREE.Mesh(sharedOrcDoorGeo, doorMat); door.position.set(0, 1.75, 4.0); hutGroup.add(door);
            
            const leftTusk = new THREE.Mesh(sharedOrcTuskGeo, sharedOrcTuskMat); leftTusk.position.set(-1.8, 1.5, 4.5); leftTusk.rotation.x = -0.3; leftTusk.rotation.z = 0.3; leftTusk.castShadow = false; hutGroup.add(leftTusk);
            const rightTusk = new THREE.Mesh(sharedOrcTuskGeo, sharedOrcTuskMat); rightTusk.position.set(1.8, 1.5, 4.5); rightTusk.rotation.x = -0.3; rightTusk.rotation.z = -0.3; rightTusk.castShadow = false; hutGroup.add(rightTusk);
            
            const pole = new THREE.Mesh(sharedOrcPoleGeo, sharedOrcLogMat); pole.position.set(3, 3, 2); pole.rotation.z = -0.2; pole.castShadow = false; hutGroup.add(pole);
            const banner = new THREE.Mesh(sharedOrcBannerGeo, sharedOrcBannerMat); banner.position.set(3.5, 5.5, 2); banner.rotation.z = -0.2; banner.castShadow = false; hutGroup.add(banner);
            
            hutGroup.position.set(x, yBase, z); hutGroup.castShadow = false;
            
            // [CRITICAL OPTIMIZATION] 충돌 등록 최소화
            // 기존에는 hutGroup의 모든 자식(장식 포함 10개 이상)을 충돌체로 등록했음.
            // 이제는 메인 '벽(Wall)'만 충돌체로 등록함. 장식은 통과 가능.
            
            // 1. Scene에 추가 (보이게 하기 위해)
            scene.add(hutGroup);
            
            // 2. Objects 배열 등록 (총알 충돌용 - 원하면 장식도 맞게 할 수 있지만, 여기선 Wall만 등록하여 최적화)
            wall.userData = { type: 'object', health: 15000, maxHealth: 15000 };
            objects.push(wall); // 총알은 벽에만 맞음 (장식은 통과)
            
            // 3. 청크 충돌 등록 (플레이어 이동용)
            // 오직 벽(Wall)만 물리 연산에 참여시킴.
            const cKey = `${Math.round(x/CHUNK_SIZE)},${Math.round(z/CHUNK_SIZE)}`;
            registerChunkObject(cKey, wall);
            
            // *참고: 만약 문이나 다른 큰 부위도 막고 싶다면 그것만 선별적으로 registerChunkObject 호출
        }

        function createOrc(x, z, yBase, isChief) {
            // [OPTIMIZATION] 오크 생성 시에도 공유 메테리얼 활용 (색상 변경이 필요하므로 clone 후 사용 or 별도 처리)
            // 여기서는 단순화를 위해 기존 로직 유지하되, 그림자만 확실히 끔 (기존 코드에서 이미 적용됨)
            const orcColor = isChief ? 0x006400 : 0x228B22; const scale = isChief ? 1.5 : 1.1;
            const orcMat = new THREE.MeshLambertMaterial({ color: orcColor }); 
            const bodyGeo = new THREE.CylinderGeometry(0.6 * scale, 0.5 * scale, 1.8 * scale, 8); const orc = new THREE.Mesh(bodyGeo, orcMat); orc.position.set(x, yBase + (0.9 * scale), z); orc.castShadow = false;
            const name = isChief ? "오크 워치프" : "오크 전사"; orc.name = `orc_${Math.floor(x)}_${Math.floor(z)}`;
            
            const headGeo = new THREE.BoxGeometry(0.5 * scale, 0.5 * scale, 0.5 * scale); const head = new THREE.Mesh(headGeo, orcMat); head.position.y = 1.1 * scale; head.castShadow = false; orc.add(head);
            const weaponGeo = new THREE.BoxGeometry(0.1, 0.8 * scale, 0.3 * scale); const weaponMat = new THREE.MeshStandardMaterial({ color: 0x555555 }); const weapon = new THREE.Mesh(weaponGeo, weaponMat); weapon.position.set(0.5 * scale, 0.5 * scale, 0.4 * scale); weapon.rotation.x = Math.PI / 2; weapon.castShadow = false; orc.add(weapon);
            const health = isChief ? 3000 : 800; const speed = isChief ? 28 : 32; 
            // [FIX] wanderTarget 초기값을 null로 설정하여 (0,0,0)으로 이동하는 문제 해결
            orc.userData = { health: health, maxHealth: health, speed: speed, originalSpeed: speed, type: 'zombie', isOrc: true, name: name, originalColor: orcMat.color.clone(), state: 'idle', lastAttackTime: 0, attackCooldown: 1500, attackRange: 2.0 * scale, detectionRange: 200, lastMoveTime: 0, wanderTarget: null, path: [], currentPathIndex: 0, lastPathUpdate: 0, pathUpdateInterval: 1000, stuckTime: 0, stuckThreshold: 1000, lastPosition: orc.position.clone(), targetPortal: null, isUsingPortal: false, portalCooldown: 1000, lastPortalUse: 0, portalCheckInterval: 500, lastPortalCheck: 0, isAtPortalEntrance: false, targetHeight: 0, playerElevated: false, lastKnownPlayerPosition: new THREE.Vector3(), velocityY: 0, isJumping: false, isProvoked: false };
            scene.add(orc); zombies.push(orc); 
        }

        function createBoss(type, x, z, yBase) {
            let bossMesh, bossHealth, bossName, scale, speed, color;
            if (type === 'witch') {
                bossHealth = 5000; bossName = "저주받은 마녀"; scale = 1.2; speed = 20.0; color = 0x800080; 
                const mat = new THREE.MeshLambertMaterial({ color: color }); bossMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.5 * scale, 0.5 * scale, 1.8 * scale, 8), mat);
                // [수정] 보스 장신구 그림자 제거
                const hat = new THREE.Mesh(new THREE.ConeGeometry(0.4 * scale, 1.0 * scale, 16), new THREE.MeshLambertMaterial({ color: 0x220022 })); hat.position.y = 1.2 * scale; hat.castShadow = false; bossMesh.add(hat);
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0x4a2e16 })); staff.position.set(0.6, 0.5, 0.4); staff.rotation.x = Math.PI / 4; staff.castShadow = false; bossMesh.add(staff);
            } else if (type === 'fire_demon') {
                bossHealth = 50000; bossName = "불의 악마"; scale = 10.0; speed = 12.0; color = 0xff4500; 
                const mat = new THREE.MeshLambertMaterial({ color: color, emissive: 0x550000 }); bossMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.6 * scale, 0.4 * scale, 2.0 * scale, 16), mat);
                const horn1 = new THREE.Mesh(new THREE.ConeGeometry(0.2 * scale, 0.8 * scale, 8), new THREE.MeshLambertMaterial({ color: 0x000000 })); horn1.position.set(0.3 * scale, 1.1 * scale, 0); horn1.rotation.z = -0.3; horn1.castShadow = false; bossMesh.add(horn1);
                const horn2 = horn1.clone(); horn2.position.set(-0.3 * scale, 1.1 * scale, 0); horn2.rotation.z = 0.3; horn2.castShadow = false; bossMesh.add(horn2);
            }
            bossMesh.position.set(x, yBase + (0.9 * scale), z); bossMesh.castShadow = false;
            bossMesh.userData = { type: 'boss', bossType: type, name: bossName, health: bossHealth, maxHealth: bossHealth, scale: scale, speed: speed, state: 'idle', lastAttackTime: 0, attackCooldown: type === 'witch' ? 2000 : 3000, attackRange: type === 'witch' ? 40 : 8, detectionRange: 300, lastTeleportTime: 0, teleportCooldown: 8000, originalColor: new THREE.Color(color) };
            scene.add(bossMesh); bosses.push(bossMesh); objects.push(bossMesh); 
        }

        function updateBosses(delta, now, playerPos) {
            let activeBoss = null; let minDst = 300; 
            
            // [FIX] 보스 인공지능에도 안전 구역 로직 적용
            const isSafeZone = (hasLeftSafeZone === 0);

            bosses.forEach((boss, index) => {
                if (boss.userData.health <= 0) { handleBossDeath(boss, index); return; }
                const dist = boss.position.distanceTo(playerPos);
                
                // [FIX] 스폰 보호: 안전 구역이고, 보스가 데미지를 입지 않았다면(풀피) 플레이어 무시
                // 플레이어가 보스를 때리면 체력이 깎이므로 그때부터는 공격 시작함
                if (isSafeZone && boss.userData.health >= boss.userData.maxHealth) return;

                if (dist < minDst) { minDst = dist; activeBoss = boss; }
                if (dist < boss.userData.detectionRange) {
                    boss.lookAt(playerPos.x, boss.position.y, playerPos.z);
                    const direction = playerPos.clone().sub(boss.position).normalize(); direction.y = 0;
                    if (boss.userData.bossType === 'witch') { handleWitchAI(boss, playerPos, dist, now, delta, direction); } 
                    else {
                        if (dist > boss.userData.attackRange) { boss.position.add(direction.multiplyScalar(boss.userData.speed * delta)); const groundY = getTerrainHeight(boss.position.x, boss.position.z); boss.position.y = groundY + (0.9 * boss.userData.scale); } 
                        else { if (now - boss.userData.lastAttackTime > boss.userData.attackCooldown) { boss.userData.lastAttackTime = now; attackPlayer(25); showChat('불의 악마', '크아앙!! (충격파)'); createDebrisEffect(playerPos, new THREE.Color(0xff4500), 10); } }
                    }
                }
            });
            const bossContainer = document.getElementById('boss-container');
            if (activeBoss) {
                bossContainer.style.display = 'flex'; document.getElementById('boss-name').textContent = activeBoss.userData.name;
                const hpPercent = (activeBoss.userData.health / activeBoss.userData.maxHealth) * 100; document.getElementById('boss-bar-fill').style.width = `${hpPercent}%`;
                if (activeBoss.userData.bossType === 'fire_demon') { bossContainer.classList.add('boss-fire'); } else { bossContainer.classList.remove('boss-fire'); }
            } else { bossContainer.style.display = 'none'; }
        }
        
        function handleWitchAI(boss, playerPos, dist, now, delta, direction) {
            if ((dist < 8 || Math.random() < 0.005) && now - boss.userData.lastTeleportTime > boss.userData.teleportCooldown) { castWitchTeleport(boss, playerPos); boss.userData.lastTeleportTime = now; return; }
            if (dist > boss.userData.attackRange) { boss.position.add(direction.multiplyScalar(boss.userData.speed * delta)); const groundY = getTerrainHeight(boss.position.x, boss.position.z); boss.position.y = groundY + (0.9 * boss.userData.scale); }
            if (now - boss.userData.lastAttackTime > boss.userData.attackCooldown) {
                boss.userData.lastAttackTime = now; const rand = Math.random();
                if (rand < 0.05) { castWitchSummon(boss); } else if (rand < 0.45) { castWitchExplosion(boss, playerPos); } else { castWitchMultiShot(boss, playerPos); }
            }
        }

        function castWitchTeleport(boss, playerPos) {
            createDebrisEffect(boss.position, new THREE.Color(0x800080), 20); const angle = Math.random() * Math.PI * 2; const radius = 15 + Math.random() * 10; const newX = playerPos.x + Math.cos(angle) * radius; const newZ = playerPos.z + Math.sin(angle) * radius; const newY = getTerrainHeight(newX, newZ); boss.position.set(newX, newY + (0.9 * boss.userData.scale), newZ); createDebrisEffect(boss.position, new THREE.Color(0x800080), 20); showChat('저주받은 마녀', '어딜 보는 거냐? 흐흐흐...');
        }
        function castWitchSummon(boss) {
            showChat('저주받은 마녀', '일어나라, 나의 종들이여!'); createDebrisEffect(boss.position, new THREE.Color(0x00ff00), 15);
            for(let i=0; i<2; i++) { const angle = (Math.PI * 2 / 2) * i; const r = 3; const zx = boss.position.x + Math.cos(angle) * r; const zz = boss.position.z + Math.sin(angle) * r; const zy = getTerrainHeight(zx, zz); createZombie(zx, zz, 300, zy); const newZombie = zombies[zombies.length - 1]; newZombie.userData.state = 'chase'; newZombie.userData.lastKnownPlayerPosition.copy(playerInVehicle ? playerInVehicle.position : gameState.position); createDebrisEffect(new THREE.Vector3(zx, zy, zz), new THREE.Color(0x00ff00), 5); }
        }
        function castWitchExplosion(boss, playerPos) { showChat('저주받은 마녀', '불타올라라!'); createHazardZone(playerPos.x, playerPos.y, playerPos.z, 5.0, 2000, 30); }
        function castWitchMultiShot(boss, targetPos) {
            const baseDir = targetPos.clone().sub(boss.position).normalize(); const angles = [-0.3, 0, 0.3];
            angles.forEach(angle => { const bullet = new THREE.Mesh(sharedBulletGeo, new THREE.MeshBasicMaterial({ color: 0x800080 })); bullet.position.copy(boss.position); bullet.position.y += 2; const dir = baseDir.clone(); dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle); bullet.userData = { velocity: dir, speed: 25, owner: 'enemy', damage: 15, spawnPosition: bullet.position.clone() }; scene.add(bullet); bullets.push(bullet); });
        }

        function createHazardZone(x, y, z, radius, duration, damage) {
            const geometry = new THREE.CylinderGeometry(radius, radius, 0.2, 32); const material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 }); const zone = new THREE.Mesh(geometry, material); const groundY = getTerrainHeight(x, z); zone.position.set(x, groundY + 0.1, z); scene.add(zone); const hazard = { mesh: zone, expiry: Date.now() + duration, damage: damage, radius: radius, triggered: false }; hazardZones.push(hazard);
        }
        function updateHazardZones(now) {
            for (let i = hazardZones.length - 1; i >= 0; i--) {
                const zone = hazardZones[i]; const remaining = zone.expiry - now;
                if (remaining > 0) { zone.mesh.material.opacity = 0.3 + Math.sin(now * 0.01) * 0.2; } else { const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position; const distSq = zone.mesh.position.distanceToSquared(playerPos); createDebrisEffect(zone.mesh.position, new THREE.Color(0xff4500), 20); if (distSq < zone.radius * zone.radius) { attackPlayer(zone.damage); showChat('시스템', '마법 폭발에 휘말렸습니다!'); } scene.remove(zone.mesh); hazardZones.splice(i, 1); }
            }
        }
        function handleBossDeath(boss, index) { 
            showChat('시스템', `⚔️ 전설적인 적 처치: ${boss.userData.name}!`); 
            addMoloch(1000 + Math.floor(Math.random() * 1000)); 
            gainXP(500); // 보스 XP 보상
            createDebrisEffect(boss.position, boss.userData.originalColor, 50); scene.remove(boss); bosses.splice(index, 1); objects = objects.filter(o => o !== boss); document.getElementById('boss-container').style.display = 'none'; 
        }

        function addBoxInstance(matrices, proxies, x, y, z, w, h, d, userDataBase, originalColor) {
            dummy.position.set(x, y, z); dummy.rotation.set(0, 0, 0); dummy.scale.set(w, h, d); dummy.updateMatrix(); matrices.push(dummy.matrix.clone());
            const proxy = new THREE.Mesh(sharedBoxGeo, invisibleMat); proxy.position.copy(dummy.position); proxy.rotation.copy(dummy.rotation); proxy.scale.copy(dummy.scale); proxy.visible = true; proxy.userData = { ...userDataBase, originalColor: originalColor }; scene.add(proxy); objects.push(proxy); proxies.push(proxy);
            if (userDataBase.type === 'floor' || userDataBase.type === 'roof') { structures.push(proxy); }
        }

        function collectBuildingData(x, z, yBase, wallMatrices, wallProxies, roofMatrices, roofProxies) {
            const size = { width: 12, height: 9, depth: 12 }; const foundationDepth = 15; const totalHeight = size.height + foundationDepth; const centerY = yBase + (size.height - foundationDepth) / 2; const userData = { health: 100000, maxHealth: 100000, type: 'object' }; const color = sharedCityMatBrown.color.clone();
            addBoxInstance(wallMatrices, wallProxies, x, centerY, z, size.width, totalHeight, size.depth, userData, color);
            const roofHeight = 3; dummy.position.set(x, yBase + size.height + (roofHeight / 2), z); dummy.rotation.set(0, Math.PI / 4, 0); dummy.scale.set(1, 1, 1); dummy.updateMatrix(); roofMatrices.push(dummy.matrix.clone());
            const roofProxy = new THREE.Mesh(sharedConeGeo, invisibleMat); roofProxy.position.copy(dummy.position); roofProxy.rotation.copy(dummy.rotation); roofProxy.visible = true; roofProxy.userData = { type: 'roof', originalColor: sharedRoofMat.color.clone() }; scene.add(roofProxy); objects.push(roofProxy); roofProxies.push(roofProxy); structures.push(roofProxy);
            const entrancePos = new THREE.Vector3(x, yBase + 0.5, z + 7); const exitPos = new THREE.Vector3(x, yBase + size.height + 0.9, z); createPortal(entrancePos, exitPos, `building_${Math.floor(x)}_${Math.floor(z)}`);
        }

        function collectHighriseData(x, z, yBase, matrices, proxies) {
            // [OPTIMIZATION] 건물 벽 통합 (프레임 드랍 방지)
            // 기존: 층마다 벽을 따로 생성 -> 변경: 건물 전체 높이만큼 벽을 한 번에 생성
            const dim = { w: 30, d: 40, h: 10, floors: 3 }; 
            const wallThickness = 0.5; 
            const buildingHealth = 50000; 
            const totalHeight = dim.h * dim.floors;
            const yOffset = yBase - (wallThickness / 2); 
            const buildingId = `highrise_${Math.floor(x)}_${Math.floor(z)}`; 
            const color = sharedCityMatGray.color.clone(); 
            const userData = { health: buildingHealth, maxHealth: buildingHealth, type: 'object', isHighrise: true };
            
            // 1. 기초 공사 (바닥)
            const foundationHeight = 10; 
            const fData = { ...userData, type: 'floor', isSteppable: true, stepHeight: 0.2 }; 
            addBoxInstance(matrices, proxies, x, yBase - (foundationHeight/2) + 0.2, z, dim.w + 0.5, foundationHeight, dim.d + 0.5, fData, color);

            // 2. 수직 기둥 (사이드 벽) - 건물 전체 높이만큼 통으로 생성
            const windowWidth = 8; 
            const sideWallLen = (dim.d - windowWidth) / 2; 
            const pillarY = yOffset + totalHeight / 2;
            
            // 오른쪽 벽 기둥 (앞/뒤)
            addBoxInstance(matrices, proxies, x + dim.w/2, pillarY, z - (dim.d + windowWidth)/4, wallThickness, totalHeight, sideWallLen, userData, color);
            addBoxInstance(matrices, proxies, x + dim.w/2, pillarY, z + (dim.d + windowWidth)/4, wallThickness, totalHeight, sideWallLen, userData, color);
            
            // 왼쪽 벽 기둥 (앞/뒤)
            addBoxInstance(matrices, proxies, x - dim.w/2, pillarY, z - (dim.d + windowWidth)/4, wallThickness, totalHeight, sideWallLen, userData, color);
            addBoxInstance(matrices, proxies, x - dim.w/2, pillarY, z + (dim.d + windowWidth)/4, wallThickness, totalHeight, sideWallLen, userData, color);

            // 3. 뒷벽 (통짜)
            addBoxInstance(matrices, proxies, x, pillarY, z - dim.d/2, dim.w + wallThickness, totalHeight, wallThickness, userData, color);

            // 4. 앞벽 (1층 입구 + 2층 이상 통짜)
            const entranceWidth = 6; 
            const entranceWallW = dim.w / 2 - entranceWidth/2; 
            
            // 1층 입구 (양옆)
            const floor0Y = yOffset + dim.h / 2;
            addBoxInstance(matrices, proxies, x - (dim.w - entranceWallW)/2, floor0Y, z + dim.d/2, entranceWallW, dim.h, wallThickness, userData, color);
            addBoxInstance(matrices, proxies, x + (dim.w - entranceWallW)/2, floor0Y, z + dim.d/2, entranceWallW, dim.h, wallThickness, userData, color);
            
            // 1층 입구 포탈
            const entrancePos = new THREE.Vector3(x, yBase + 0.5, z + (dim.d / 2) + 2); 
            const exitPos = new THREE.Vector3(x, (1 * dim.h + yOffset) + (wallThickness / 2) + 0.9, z); 
            createPortal(entrancePos, exitPos, buildingId);

            // 2층 이상 (통짜 벽)
            if (dim.floors > 1) {
                const upperHeight = dim.h * (dim.floors - 1);
                const upperY = yOffset + dim.h + upperHeight / 2;
                addBoxInstance(matrices, proxies, x, upperY, z + dim.d/2, dim.w + wallThickness, upperHeight, wallThickness, userData, color);
            }

            // 5. 층별 요소 (바닥판, 창문 틀, 트리거)
            const windowHeight = 4;
            const sillHeight = (dim.h - windowHeight) / 2; // 창문 위쪽 벽

            for (let i = 0; i < dim.floors; i++) {
                const y = i * dim.h + yOffset; 
                const wallY = y + dim.h / 2; 
                const floorData = { ...userData, type: 'floor' }; 
                
                // 층간 바닥
                addBoxInstance(matrices, proxies, x, y, z, dim.w, wallThickness, dim.d, floorData, color); 
                
                // 창문 틀 (위쪽 마감)
                addBoxInstance(matrices, proxies, x + dim.w/2, wallY + (dim.h + windowHeight)/4, z, wallThickness, sillHeight, windowWidth, userData, color);
                addBoxInstance(matrices, proxies, x - dim.w/2, wallY + (dim.h + windowHeight)/4, z, wallThickness, sillHeight, windowWidth, userData, color);

                // 계단 트리거 & 포탈
                const triggerGeo = new THREE.BoxGeometry(4, dim.h, 4);
                if (i < dim.floors - 1) { 
                    const triggerMatUp = new THREE.MeshBasicMaterial({color: 0x00ff00, transparent: true, opacity: 0.3}); 
                    const triggerUp = new THREE.Mesh(triggerGeo, triggerMatUp); 
                    triggerUp.position.set(x + dim.w/2 - 5, y + dim.h/2, z); 
                    triggerUp.userData = { type: 'teleporter', targetPosition: new THREE.Vector3(x, (i + 1) * dim.h + 1.8 + yOffset, z) }; 
                    scene.add(triggerUp); stairTriggers.push(triggerUp); 
                    
                    const pEntrance = new THREE.Vector3(x + dim.w/2 - 5, y + 0.5, z); 
                    const pExit = new THREE.Vector3(x, ((i + 1) * dim.h + yOffset) + (wallThickness / 2) + 0.9, z); 
                    createPortal(pEntrance, pExit, buildingId); 
                } else { 
                    const triggerMatRoof = new THREE.MeshBasicMaterial({color: 0x0088ff, transparent: true, opacity: 0.3}); 
                    const triggerRoof = new THREE.Mesh(triggerGeo, triggerMatRoof); 
                    triggerRoof.position.set(x + dim.w/2 - 5, y + dim.h/2, z); 
                    const roofY = dim.floors * dim.h + yOffset; 
                    triggerRoof.userData = { type: 'teleporter', targetPosition: new THREE.Vector3(x, roofY + 1.8, z) }; 
                    scene.add(triggerRoof); stairTriggers.push(triggerRoof); 
                    
                    const pEntrance = new THREE.Vector3(x + dim.w/2 - 5, y + 0.5, z); 
                    const pExit = new THREE.Vector3(x, roofY + 0.9, z); 
                    createPortal(pEntrance, pExit, buildingId); 
                }
                
                if (i < 3) { createBuildingLoot(x + (Math.random()-0.5)*(dim.w-4), y + 0.5, z + (Math.random()-0.5)*(dim.d-4)); }
            }
            
            // 옥상
            const roofY = dim.floors * dim.h + yOffset; 
            const roofData = { ...userData, type: 'roof' }; 
            addBoxInstance(matrices, proxies, x, roofY, z, dim.w, wallThickness, dim.d, roofData, color); 
            for(let k=0; k<2; k++) { createBuildingLoot(x + (Math.random()-0.5)*(dim.w-4), roofY + 0.5, z + (Math.random()-0.5)*(dim.d-4)); }
        }
        
        function createNPC(x, z, color, name, dialogue, yBase) { 
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2, 8), new THREE.MeshLambertMaterial({ color: color })); body.position.set(x, yBase + 1, z); 
            
            // [수정] 상인(Merchant)만 그림자 켜고, 나머지는 끔
            const isMerchant = (name === '상인');
            body.castShadow = isMerchant; 
            
            body.userData = { type: 'npc', name: name, dialogue: dialogue, dialogueIndex: 0, spawnPosition: new THREE.Vector3(x, yBase + 1, z), wanderTarget: null, lastMoveTime: 0, speed: 2.5 };
            if (name === '생존자') { body.userData.tutorialDialogue = [ "1. [캐릭터 조작] WASD로 이동하고, Shift로 달립니다. Space는 점프, F키는 상호작용입니다.", "2. [차량 조작] 차량 근처에서 F키로 타고 내립니다. WASD로 운전하며, 좀비들을 들이받아 날려버릴 수 있습니다.", "3. [생존 위협] 좀비와 적들은 소리를 듣고 쫓아옵니다. 특히 밤에는 시야가 좁아지고 적들이 더 위험해집니다.", "4. [전투 방법] 마우스 왼쪽 버튼으로 사격, 우클릭으로 조준합니다. 탄약이 떨어지면 R키로 재장전하세요.", "5. [줌 조절] 우클릭 조준 중에 마우스 휠을 굴리면 줌을 조절할 수 있습니다. T키로 최대 배율을 변경해보세요!", "6. [지형 주의] 화산 지대의 용암에 닿으면 큰 피해를 입습니다! 조심하세요!" ]; body.userData.tutorialIndex = 0; }
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshLambertMaterial({ color: 0x333333 })); head.position.set(0, 1.3, 0); 
            
            // [수정] 머리 그림자도 상인만
            head.castShadow = isMerchant; 
            
            body.add(head); scene.add(body); npcs.push(body);
        }

        function updateNPCs(delta) {
            const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position;
            npcs.forEach(npc => {
                const data = npc.userData; const inFrustum = isPositionInView(npc.position); let isVisible = false; if (inFrustum) { isVisible = checkLineOfSight(gameState.position, npc.position); }
                if (isVisible) { npc.lookAt(playerPos.x, npc.position.y, playerPos.z); data.wanderTarget = null; } else { if (!data.wanderTarget) { const radius = 20; const angle = Math.random() * Math.PI * 2; const dist = Math.random() * radius; data.wanderTarget = new THREE.Vector3(data.spawnPosition.x + Math.cos(angle) * dist, data.spawnPosition.y, data.spawnPosition.z + Math.sin(angle) * dist); } const distToTarget = new THREE.Vector2(npc.position.x - data.wanderTarget.x, npc.position.z - data.wanderTarget.z).length(); if (distToTarget < 0.5) { if (Math.random() < 0.02) { data.wanderTarget = null; } } else { const direction = data.wanderTarget.clone().sub(npc.position).normalize(); direction.y = 0; const velocity = direction.multiplyScalar(data.speed * delta); npc.position.add(velocity); npc.lookAt(data.wanderTarget.x, npc.position.y, data.wanderTarget.z); const groundY = getTerrainHeight(npc.position.x, npc.position.z); npc.position.y = groundY + 1.0; } }
            });
        }

        function createFlare(position) { if (flares.length >= 5) { const oldFlare = flares.shift(); scene.remove(oldFlare); if (oldFlare.userData.light) scene.remove(oldFlare.userData.light); } const flareGeometry = new THREE.SphereGeometry(0.2, 8, 8); const flareMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa }); const flareMesh = new THREE.Mesh(flareGeometry, flareMaterial); flareMesh.position.copy(position); const light = new THREE.PointLight(0xffaa00, 2, 50); light.position.copy(position); light.position.y += 0.5; light.castShadow = false; scene.add(light); flareMesh.userData = { light: light, lifespan: 10.0 }; scene.add(flareMesh); flares.push(flareMesh); showChat('시스템', '섬광탄이 설치되었습니다.'); }
        function updateFlares(delta) { for(let i=flares.length-1; i>=0; i--) { const f = flares[i]; f.userData.lifespan -= delta; if(f.userData.lifespan <= 0) { scene.remove(f.userData.light); scene.remove(f); flares.splice(i, 1); } } }
        
        // [FIXED] updateZombies 함수 복구
        function updateZombies(delta) {
            const now = Date.now(); const targetPos = playerInVehicle ? playerInVehicle.position : gameState.position; 
            const playerBaseSpeed = getMoveSpeed();
            const isDayTime = !isNight;
            
            for (let index = zombies.length - 1; index >= 0; index--) {
                const enemy = zombies[index]; if (!enemy || !enemy.parent) { zombies.splice(index, 1); continue; } 
                const data = enemy.userData;
                const distToPlayerSq = enemy.position.distanceToSquared(targetPos);

                if (distToPlayerSq > 90000) { enemy.visible = false; continue; } else { enemy.visible = true; }

                const isClose = distToPlayerSq < 2500; 
                const updateRate = isClose ? 1 : 3;
                
                if ((frameCount + index) % updateRate !== 0) {
                     if (data.isJumping) {
                        data.velocityY -= 0.03 * updateRate; 
                        enemy.position.y += data.velocityY * updateRate;
                        const groundY = getTerrainHeight(enemy.position.x, enemy.position.z);
                        if (enemy.position.y <= groundY + 0.9) {
                            enemy.position.y = groundY + 0.9;
                            data.isJumping = false;
                        }
                     }
                     continue; 
                }
                
                const effectiveDelta = delta * updateRate;

                if (isDayTime && !data.isTroll && !data.isOrc && data.health > 0) {
                    if ((frameCount + index) % 60 === 0) {
                        const damagePerSec = 100; 
                        data.health -= damagePerSec;
                        const healthPercent = Math.max(0, data.health / data.maxHealth);
                        enemy.material.color.copy(data.originalColor).lerp(new THREE.Color(0xff0000), 0.5); 
                        setTimeout(() => { if (enemy && enemy.material) { enemy.material.color.copy(data.originalColor).lerp(new THREE.Color(0xffffff), 1 - healthPercent); } }, 200);
                        if (data.health <= 0) { handleZombieDeath(enemy, index, false); continue; }
                    }
                }
                
                if (isNight) { data.speed = playerBaseSpeed + 0.01; } else { data.speed = Math.max(0, playerBaseSpeed - 0.1); }
                if (data.health <= 0) { handleZombieDeath(enemy, index, true); continue; }
                
                let zombieGroundY = -100; let validGroundHit = null; const biome = getBiome(enemy.position.x, enemy.position.z);
                if (biome !== 'city') { zombieGroundY = getTerrainHeight(enemy.position.x, enemy.position.z); } else { 
                    if (data.isJumping || (frameCount + index) % 10 === 0) {
                        raycaster.far = 20; raycaster.set(enemy.position.clone().add(new THREE.Vector3(0, 1, 0)), new THREE.Vector3(0, -1, 0)); const zombieIntersects = raycaster.intersectObjects(structures, true); 
                        validGroundHit = zombieIntersects.find(hit => {
                            if (hit.point.y >= enemy.position.y + 2.0) return false;
                            const isStructure = hit.object.userData.type === 'roof' || hit.object.userData.type === 'floor';
                            const isGround = hit.object.geometry.type === 'PlaneGeometry';
                            if (!isStructure && !isGround) return false;
                            if (isGround && hit.distance > 5.0) return false;
                            return true;
                        });
                        if (validGroundHit) { zombieGroundY = validGroundHit.point.y; } else { zombieGroundY = getTerrainHeight(enemy.position.x, enemy.position.z); }
                    } else {
                        zombieGroundY = getTerrainHeight(enemy.position.x, enemy.position.z);
                    }
                }

                let heightOffset = 0.9; if (data.isTroll) heightOffset = 1.35; if (data.isOrc) heightOffset = data.name.includes('워치프') ? 1.35 : 1.0;
                if (data.isJumping) { enemy.position.y += data.velocityY; data.velocityY -= 0.03 * updateRate; if (enemy.position.y <= zombieGroundY + heightOffset && data.velocityY < 0) { enemy.position.y = zombieGroundY + heightOffset; data.isJumping = false; data.velocityY = 0; } } else { if (biome !== 'city' || validGroundHit) { enemy.position.y = zombieGroundY + heightOffset; } }
                
                let currentTargetPos = targetPos; let isTargetPlayer = true;
                if (data.customTarget) { if (data.customTarget.parent && data.customTarget.userData.health > 0) { currentTargetPos = data.customTarget.position; isTargetPlayer = false; } else { data.customTarget = null; } }

                if (!currentTargetPos || !enemy || !enemy.position) continue; const distSq = enemy.position.distanceToSquared(currentTargetPos); const distToTarget = Math.sqrt(distSq); const heightDiff = currentTargetPos.y - enemy.position.y; data.targetHeight = heightDiff; data.playerElevated = isTargetPlayer && heightDiff > 3; 
                const isSafeZone = isTargetPlayer && (hasLeftSafeZone === 0); const isProvoked = data.isProvoked;

                if (now - data.lastPortalCheck > data.portalCheckInterval) { 
                    data.lastPortalCheck = now; const verticalDist = Math.abs(heightDiff);
                    if (verticalDist > 2.5 && distToTarget < 80) { data.portalAction = findBestPortalAction(enemy.position, currentTargetPos.y); } else { data.portalAction = null; } 
                }

                let hasLineOfSight = false; 
                if (!isSafeZone || isProvoked) { 
                    if (data.state === 'chase' && (frameCount + index) % 10 !== 0) {
                        hasLineOfSight = true; 
                    } else {
                        hasLineOfSight = checkLineOfSight(enemy.position, currentTargetPos); 
                    }
                } 
                if (hasLineOfSight) { data.lastKnownPlayerPosition.copy(currentTargetPos); }
                
                const moved = enemy.position.distanceTo(data.lastPosition); if (!data.isJumping && moved < 0.1 * effectiveDelta && (data.state === 'chase' || data.state === 'portal')) { data.stuckTime += effectiveDelta * 1000; } else { data.stuckTime = 0; } data.lastPosition.copy(enemy.position);
                
                if (data.portalAction && !data.isUsingPortal && (now - data.lastPortalUse > data.portalCooldown)) { data.state = 'portal'; } 
                else if (((!data.isOrc && !isSafeZone) || isProvoked) && distToTarget <= data.attackRange && Math.abs(heightDiff) < 1.5) { data.state = 'attack'; } 
                else if (isProvoked || (!data.isOrc && !isSafeZone && (distToTarget <= data.detectionRange || !isTargetPlayer) && (hasLineOfSight || data.lastKnownPlayerPosition.lengthSq() > 0))) { data.state = 'chase'; } 
                else if (data.stuckTime > data.stuckThreshold) { data.state = 'stuck'; } else { data.state = 'wander'; }
                
                switch (data.state) { case 'portal': handlePortalState(enemy, data, now, effectiveDelta); break; case 'attack': handleAttackState(enemy, data, now, currentTargetPos, isTargetPlayer); break; case 'chase': handleChaseState(enemy, data, now, effectiveDelta, hasLineOfSight, currentTargetPos); break; case 'stuck': handleStuckState(enemy, data, effectiveDelta); break; case 'wander': handleWanderState(enemy, data, now, effectiveDelta); break; case 'knockback': handleKnockbackState(enemy, data, effectiveDelta); break; }
            } 
        }

        function findBestPortalAction(zombiePos, targetY) {
            let bestPortal = null; let minDist = Infinity;
            for (const portal of portals) {
                if (!portal.isActive) continue;
                const distToEntrance = zombiePos.distanceTo(portal.entrance);
                if (distToEntrance < 30) {
                    const heightDiff = Math.abs(portal.exit.y - targetY);
                    if (heightDiff < 5) { 
                        if (distToEntrance < minDist) { minDist = distToEntrance; bestPortal = portal; }
                    }
                }
            }
            return bestPortal;
        }

        function handleChaseState(enemy, data, now, delta, hasLOS, targetPos) {
            if (!targetPos && data.lastKnownPlayerPosition.lengthSq() > 0) targetPos = data.lastKnownPlayerPosition;
            if (!targetPos) { data.state = 'wander'; return; }
            
            const direction = targetPos.clone().sub(enemy.position).normalize(); direction.y = 0;
            if (data.stuckTime > 500) { direction.x += (Math.random() - 0.5); direction.z += (Math.random() - 0.5); direction.normalize(); }

            const velocity = direction.multiplyScalar(data.speed * delta);
            enemy.position.add(velocity);
            enemy.lookAt(targetPos.x, enemy.position.y, targetPos.z);
            
            if (hasLOS && !data.isJumping && data.playerElevated && data.targetHeight > 2.0) { data.velocityY = 0.3; data.isJumping = true; }
        }

        function handleWanderState(enemy, data, now, delta) {
            if (!data.wanderTarget) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 5 + Math.random() * 10;
                data.wanderTarget = new THREE.Vector3(enemy.position.x + Math.cos(angle) * dist, enemy.position.y, enemy.position.z + Math.sin(angle) * dist);
            }
            const dist = new THREE.Vector2(enemy.position.x - data.wanderTarget.x, enemy.position.z - data.wanderTarget.z).length();
            if (dist < 1) { data.wanderTarget = null; return; }
            
            const direction = data.wanderTarget.clone().sub(enemy.position).normalize(); direction.y = 0;
            enemy.position.add(direction.multiplyScalar(data.speed * 0.5 * delta));
            enemy.lookAt(data.wanderTarget.x, enemy.position.y, data.wanderTarget.z);
        }

        function handleStuckState(enemy, data, delta) {
            if (!data.isJumping) { data.velocityY = 0.4; data.isJumping = true; }
            const direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
            enemy.position.add(direction.multiplyScalar(data.speed * delta));
            data.stuckTime -= delta * 2000; 
            if (data.stuckTime <= 0) data.state = 'chase';
        }

        function handlePortalState(enemy, data, now, delta) {
            const portal = data.portalAction;
            if (!portal) { data.state = 'chase'; return; }
            const distToEntrance = enemy.position.distanceTo(portal.entrance);
            if (distToEntrance < 1.5) {
                enemy.position.copy(portal.exit);
                data.isUsingPortal = true; data.lastPortalUse = now; data.portalAction = null; data.state = 'chase';
                showChat(data.name, "크르르... (엘리베이터 이용)");
            } else {
                const direction = portal.entrance.clone().sub(enemy.position).normalize(); direction.y = 0;
                enemy.position.add(direction.multiplyScalar(data.speed * delta));
                enemy.lookAt(portal.entrance.x, enemy.position.y, portal.entrance.z);
            }
        }

        function handleKnockbackState(enemy, data, delta) { data.state = 'chase'; }
        
        function createRangedEnemy(x, z, health, yBase) { 
            if (yBase === 0) yBase = getTerrainHeight(x, z);
            const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0x800000 }); const enemy = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 2.5, 8), enemyMaterial); enemy.position.set(x, yBase + 1.25, z); enemy.castShadow = false;
            const weaponKeys = Object.keys(WEAPON_DATABASE).filter(key => WEAPON_DATABASE[key].type !== 'Melee' && key !== 'FlashGun'); const randomWeaponKey = weaponKeys[Math.floor(Math.random() * weaponKeys.length)]; const weaponData = WEAPON_DATABASE[randomWeaponKey];
            const enemyGun = weaponData.model(); enemyGun.scale.set(1.2, 1.2, 1.2); enemyGun.name = 'enemyGun'; enemyGun.position.set(0, 0.8, 0.5); enemyGun.rotation.y = Math.PI; 
            // [수정] 적 무기 그림자 제거
            enemyGun.traverse(child => { if (child.isMesh) child.castShadow = false; });
            enemy.add(enemyGun);
            let attackRange = 40; let detectionRange = 300; let fireRateMultiplier = 2 + Math.random(); if (weaponData.type === 'SG') { attackRange = 15; } else if (weaponData.type === 'SR' || weaponData.type === 'DMR') { attackRange = 100; detectionRange = 100; fireRateMultiplier = 3.0; } else { attackRange = 60; }
            // [FIX] wanderTarget 초기값을 null로 설정
            enemy.userData = { type: 'enemy', health: health, maxHealth: health, speed: 15 + Math.random() * 5, lastShotTime: 0, fireRate: weaponData.fireRate * fireRateMultiplier, originalColor: enemyMaterial.color.clone(), weapon: randomWeaponKey, muzzle: enemyGun.getObjectByName('muzzle'), magAmmo: weaponData.magSize || 10, reloadsLeft: 20, isReloading: false, reloadStartTime: 0, outOfAmmo: (weaponData.type === 'Melee' || !weaponData.magSize), state: 'idle', lastMoveTime: 0, wanderTarget: null, detectionRange: detectionRange, attackRange: attackRange, lastKnownPlayerPosition: new THREE.Vector3(), lastPosition: enemy.position.clone(), path: [], currentPathIndex: 0, lastPathUpdate: 0, pathUpdateInterval: 1000, velocityY: 0, isJumping: false, isRepositioning: false };
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshLambertMaterial({ color: 0x600000 })); head.position.set(0, 1.4, 0); head.castShadow = false; enemy.add(head); scene.add(enemy); rangedEnemies.push(enemy); 
        }

        function createZombie(x, z, health, yBase) {
            if (yBase === 0) yBase = getTerrainHeight(x, z);
            const zombieMaterial = new THREE.MeshLambertMaterial({ color: 0x008000 }); const zombie = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.8, 8), zombieMaterial); zombie.position.set(x, yBase + 0.9, z); zombie.castShadow = false; zombie.name = `zombie_${x}_${z}`; 
            const speed = 30.1 + Math.random();
            // [FIX] wanderTarget 초기값을 null로 설정
            zombie.userData = { health: health, maxHealth: health, speed: speed, originalSpeed: speed, type: 'zombie', originalColor: zombieMaterial.color.clone(), state: 'idle', lastAttackTime: 0, attackCooldown: 2000, attackRange: 1.5, detectionRange: 100, lastMoveTime: 0, wanderTarget: null, path: [], currentPathIndex: 0, lastPathUpdate: 0, pathUpdateInterval: 1000, stuckTime: 0, stuckThreshold: 1000, lastPosition: zombie.position.clone(), targetPortal: null, isUsingPortal: false, portalCooldown: 1000, lastPortalUse: 0, portalCheckInterval: 500, lastPortalCheck: 0, isAtPortalEntrance: false, targetHeight: 0, playerElevated: false, lastKnownPlayerPosition: new THREE.Vector3(), velocityY: 0, isJumping: false, isProvoked: false, name: '좀비' };
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshLambertMaterial({ color: 0x006400 })); head.position.set(0, 1.1, 0); head.castShadow = false; zombie.add(head); scene.add(zombie); zombies.push(zombie); 
        }

        function createTroll(x, z, yBase) {
            if (yBase === 0) yBase = getTerrainHeight(x, z);
            const trollMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F }); const troll = new THREE.Mesh(new THREE.CylinderGeometry(0.75, 0.75, 2.7, 10), trollMaterial); troll.position.set(x, yBase + 1.35, z); troll.castShadow = false; troll.name = `troll_${x}_${z}`;
            const speed = 25.0 + Math.random() * 2; const health = 1500;
            // [FIX] wanderTarget 초기값을 null로 설정
            troll.userData = { health: health, maxHealth: health, speed: speed, originalSpeed: speed, type: 'zombie', isTroll: true, name: '트롤', originalColor: trollMaterial.color.clone(), state: 'idle', lastAttackTime: 0, attackCooldown: 2500, attackRange: 2.5, detectionRange: 150, lastMoveTime: 0, wanderTarget: null, path: [], currentPathIndex: 0, lastPathUpdate: 0, pathUpdateInterval: 1000, stuckTime: 0, stuckThreshold: 1000, lastPosition: troll.position.clone(), targetPortal: null, isUsingPortal: false, portalCooldown: 1000, lastPortalUse: 0, portalCheckInterval: 500, lastPortalCheck: 0, isAtPortalEntrance: false, targetHeight: 0, playerElevated: false, lastKnownPlayerPosition: new THREE.Vector3(), velocityY: 0, isJumping: false, isProvoked: false };
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshLambertMaterial({ color: 0x1a2e1a })); head.position.set(0, 1.65, 0); head.castShadow = false; troll.add(head); scene.add(troll); zombies.push(troll);
        }

        function createVehicle(x, z, yBase) { 
            const vehicle = new THREE.Group(); vehicle.name = 'vehicle';
            const bodyGeo = new THREE.BoxGeometry(2, 0.8, 3.5); const bodyMat = new THREE.MeshStandardMaterial({ color: 0x0000ff }); const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.4; 
            // [수정] 차량 그림자 제거
            body.castShadow = false; 
            
            const cabinGeo = new THREE.BoxGeometry(1.8, 0.7, 1); const cabinMat = new THREE.MeshStandardMaterial({ color: 0xAAAAFF }); const cabin = new THREE.Mesh(cabinGeo, cabinMat); cabin.position.set(0, 1.15, -0.75); 
            // [수정] 차량 캐빈 그림자 제거
            cabin.castShadow = false; 
            
            vehicle.add(body); vehicle.add(cabin);
            const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12); const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); 
            const wheelPositions = [ new THREE.Vector3(1.1, 0.3, 1.2), new THREE.Vector3(-1.1, 0.3, 1.2), new THREE.Vector3(1.1, 0.3, -1.2), new THREE.Vector3(-1.1, 0.3, -1.2) ];
            wheelPositions.forEach(pos => { const wheel = new THREE.Mesh(wheelGeo, wheelMat); wheel.position.copy(pos); wheel.rotation.z = Math.PI / 2; vehicle.add(wheel); });
            vehicle.position.set(x, yBase + 0.4, z); 
            vehicle.userData = { type: 'vehicle', health: 5000, maxHealth: 5000, collisionBox: new THREE.Box3(new THREE.Vector3(-1.1, 0, -1.75), new THREE.Vector3(1.1, 1.85, 1.75)), velocity: new THREE.Vector3(), steering: 0, speed: 0, maxSpeed: 7.5, acceleration: 4.0, braking: 8.0, friction: 1.5, turnSpeed: 1.5, suspension: 0.1 };
            scene.add(vehicle); vehicles.push(vehicle);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => { 
                if(isGameOver || gameState.isReloading) return; 
                if (playerInVehicle) { 
                    switch(e.code) { case 'KeyW': vehicleAcceleration = -1; break; case 'KeyS': vehicleAcceleration = 1; break; case 'KeyA': vehicleSteering = -1; break; case 'KeyD': vehicleSteering = 1; break; } 
                } else { 
                    if (!isTrading && !isStatsOpen) { 
                        switch (e.code) { case 'KeyW': controls.moveForward = true; break; case 'KeyA': controls.moveLeft = true; break; case 'KeyS': controls.moveBackward = true; break; case 'KeyD': controls.moveRight = true; break; case 'Space': controls.jump = true; break; case 'ShiftLeft': controls.sprint = true; break; } 
                    } 
                } 
                switch (e.code) { 
                    case 'KeyR': reload(); break; 
                    case 'Digit1': switchWeapon(0); break; 
                    case 'Digit2': switchWeapon(1); break; 
                    case 'Digit3': switchWeapon(2); break; 
                    case 'Digit4': switchWeapon(3); break; 
                    case 'Digit5': switchWeapon(4); break; 
                    case 'KeyF': interact(); break; 
                    case 'KeyP': toggleStatsModal(); break;
                    case 'KeyT': cycleScope(); break; // [NEW] 스코프 교체 키
                } 
            });
            document.addEventListener('keyup', (e) => { if (playerInVehicle) { switch(e.code) { case 'KeyW': if (vehicleAcceleration < 0) vehicleAcceleration = 0; break; case 'KeyS': if (vehicleAcceleration > 0) vehicleAcceleration = 0; break; case 'KeyA': if (vehicleSteering < 0) vehicleSteering = 0; break; case 'KeyD': if (vehicleSteering > 0) vehicleSteering = 0; break; } } switch (e.code) { case 'KeyW': controls.moveForward = false; break; case 'KeyA': controls.moveLeft = false; break; case 'KeyS': controls.moveBackward = false; break; case 'KeyD': controls.moveRight = false; break; case 'ShiftLeft': controls.sprint = false; case 'Space': controls.jump = false; break; } });
            
            // [FIX] WrongDocumentError Fix
            document.addEventListener('click', (event) => { 
                // UI 클릭 시 포인터 잠금 방지
                if (event.target.closest('button') || event.target.closest('#trade-modal') || event.target.closest('#stats-modal')) return;

                if (!isPointerLocked && !isTrading && !isStatsOpen) { 
                    // document.body 대신 renderer.domElement 사용 시도
                    const target = renderer ? renderer.domElement : document.body;
                    if(target && target.requestPointerLock) {
                        try {
                            target.requestPointerLock();
                        } catch(e) {
                            console.warn("Pointer lock failed:", e);
                        }
                    }
                } 
            });
            
            document.addEventListener('pointerlockchange', () => { 
                // 포인터 잠금 상태 확인 로직 개선
                isPointerLocked = !!document.pointerLockElement;
                document.getElementById('crosshair').style.display = isPointerLocked ? 'block' : 'none'; 
                document.body.style.cursor = isPointerLocked ? 'none' : 'default'; 
                if (isPointerLocked && (isTrading || isStatsOpen)) { closeTradeModal(); closeStatsModal(); } 
            });
            
            document.addEventListener('mousemove', (e) => { if (isPointerLocked) { const sensitivity = 0.0015; if (!playerInVehicle) { gameState.rotation.y -= e.movementX * sensitivity; } gameState.rotation.x -= e.movementY * sensitivity; gameState.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.rotation.x)); } });
            
            // [수정] 우클릭 줌 로직 변경: 1번(1x) -> 2번(2x) -> 3번(4x) -> 4번(8x) -> 5번(초기화)
            document.addEventListener('mousedown', (e) => { 
                if (isPointerLocked && !playerInVehicle && !gameState.isReloading) { 
                    e.preventDefault(); 
                    if (e.button === 0) {
                        shoot(); 
                    } else if (e.button === 2) { 
                        zoomClickCount++;
                        
                        // [NEW] 스코프가 없을 때는 아이언 사이트 줌(1.2배)만 가능하고 횟수 2에서 바로 꺼짐
                        const maxClicks = (unlockedScopeIndex === -1) ? 1 : unlockedScopeIndex + 1;
                        
                        if (zoomClickCount > maxClicks) {
                            // 초기화
                            zoomClickCount = 0;
                            isAiming = false;
                            currentZoomLevel = 1.0;
                            document.body.classList.remove('zoomed');
                            showChat('시스템', '줌 해제');
                        } else {
                            // 줌 진입
                            isAiming = true;
                            document.body.classList.add('zoomed');
                            
                            if (unlockedScopeIndex === -1) {
                                currentZoomLevel = 1.2; // 아이언 사이트 줌
                                showChat('시스템', '줌: 아이언 사이트');
                            } else {
                                if (zoomClickCount === 1) currentZoomLevel = 1.0; // 1x
                                else if (zoomClickCount === 2) currentZoomLevel = 2.0; // 2x
                                else if (zoomClickCount === 3) currentZoomLevel = 4.0; // 4x
                                else if (zoomClickCount === 4) currentZoomLevel = 8.0; // 8x
                                showChat('시스템', `줌: ${currentZoomLevel}배율`);
                            }
                        }
                        updateScopeUI();
                    } 
                } 
            });
            // [수정] mouseup 이벤트에서 우클릭 줌 해제 로직 제거 (토글 방식이므로 필요 없음)
            document.addEventListener('mouseup', (e) => { 
                // 기존의 우클릭 뗄 때 줌 해제하던 코드는 삭제함
            });
            
            // [수정] 휠 이벤트: 줌 미세 조절 유지 (원하면 제거 가능)
            document.addEventListener('wheel', (e) => { 
                if (isPointerLocked && !playerInVehicle && !gameState.isReloading) { 
                    const direction = e.deltaY > 0 ? 1 : -1; 
                    if (isAiming) {
                        // 휠로 미세 조절 가능 (선택 사항)
                        const maxZoom = (unlockedScopeIndex === -1) ? 1.5 : SCOPE_LEVELS[unlockedScopeIndex];
                        if (direction < 0) currentZoomLevel = Math.min(maxZoom, currentZoomLevel + 0.5);
                        else currentZoomLevel = Math.max(1.0, currentZoomLevel - 0.5);
                        updateScopeUI();
                    } else {
                        switchWeapon(gameState.currentWeaponIndex + direction); 
                    }
                } 
            });
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            window.addEventListener('resize', () => { if (camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });
            document.getElementById('restart-button').addEventListener('click', () => location.reload());
        }

        function reload() {
            if (gameState.isReloading || isTrading) return;
            const weaponObj = gameState.weapons[gameState.currentWeaponIndex]; const weaponData = WEAPON_DATABASE[weaponObj.key]; if (weaponData.type === 'Melee') return; if (weaponObj.magAmmo >= weaponData.magSize) return; const ammoType = weaponData.ammoType; if (!ammoType) return; const inventoryAmmo = gameState.ammoInventory[ammoType] || 0; if (inventoryAmmo <= 0) { showChat('시스템', '탄약이 부족합니다!'); return; }
            gameState.isReloading = true; showChat('시스템', '재장전 중...'); document.getElementById('reload-prompt').textContent = '재장전 중...'; document.getElementById('reload-prompt').style.display = 'block';
            setTimeout(() => {
                const needed = weaponData.magSize - weaponObj.magAmmo; const toLoad = Math.min(needed, inventoryAmmo); weaponObj.magAmmo += toLoad; gameState.ammoInventory[ammoType] -= toLoad;
                gameState.isReloading = false; document.getElementById('reload-prompt').textContent = '[R] 재장전 필요'; updateUI(); showChat('시스템', '재장전 완료!');
            }, weaponData.reloadTime);
        }

        function shoot() {
            const weaponObj = gameState.weapons[gameState.currentWeaponIndex]; if (!weaponObj || !muzzle) return; const weaponData = WEAPON_DATABASE[weaponObj.key]; const isMelee = (weaponData.type === 'Melee'); const isOutOfAmmo = (!isMelee && weaponObj.magAmmo <= 0); const fireRate = (isMelee || isOutOfAmmo) ? WEAPON_DATABASE["Fist"].fireRate : weaponData.fireRate; const now = Date.now(); if (now - gameState.lastShotTime < fireRate) return; gameState.lastShotTime = now;
            if (isMelee || isOutOfAmmo) { if (isOutOfAmmo) { document.getElementById('reload-prompt').style.display = 'block'; } performPunch(WEAPON_DATABASE["Fist"]); return; }
            weaponObj.magAmmo--; updateUI(); const muzzleWorldPos = new THREE.Vector3(); muzzle.getWorldPosition(muzzleWorldPos); showMuzzleFlash(muzzleWorldPos); const pellets = weaponData.pellets || 1; const spread = weaponData.spread || 0;
            
            // [MODIFIED] 오크 청각 자극 코드 제거 (요청: 오크는 데미지 입을 때만 반응)
            // 기존의 "총소리 듣고 오크가 달려오는" 로직은 삭제됨.
            if (weaponData.type !== 'Melee' && weaponData.type !== 'Special') {
                const noiseRangeSq = 50 * 50; 
                zombies.forEach(z => {
                    // 오크는 이제 소리에 반응하지 않음 (Hit 판정에서만 반응)
                    if (!z.userData.isOrc && z.userData.health > 0) {
                        if (z.position.distanceToSquared(gameState.position) < noiseRangeSq) {
                            if (z.userData.state !== 'chase' && z.userData.state !== 'attack') { z.userData.state = 'chase'; z.userData.lastKnownPlayerPosition.copy(gameState.position); z.userData.isProvoked = true; } else { z.userData.lastKnownPlayerPosition.copy(gameState.position); }
                        }
                    }
                });
            }

            for (let i = 0; i < pellets; i++) { const direction = new THREE.Vector3(); camera.getWorldDirection(direction); if (pellets > 1) { direction.x += (Math.random() - 0.5) * spread; direction.y += (Math.random() - 0.5) * spread; direction.z += (Math.random() - 0.5) * spread; direction.normalize(); } const bulletColor = weaponData.ammoType === 'Flare' ? 0xffffff : 0xffff00; const bullet = new THREE.Mesh(sharedBulletGeo, sharedBulletMat); if (weaponData.ammoType === 'Flare') { const flightLight = new THREE.PointLight(0xffaa00, 1.5, 20); bullet.add(flightLight); bullet.material = new THREE.MeshBasicMaterial({color: 0xffffff}); } bullet.position.copy(muzzleWorldPos); bullet.userData = { velocity: direction, spawnPosition: bullet.position.clone(), weaponKey: weaponObj.key, speed: weaponData.bulletSpeed, owner: 'player' }; scene.add(bullet); bullets.push(bullet); }
        }
        
        function showMuzzleFlash(position) {
            const flashEl = document.getElementById('muzzle-flash'); tempVec.copy(position); tempVec.project(camera);
            const x = (tempVec.x * .5 + .5) * window.innerWidth; const y = (-(tempVec.y * .5) + .5) * window.innerHeight;
            flashEl.style.left = `${x}px`; flashEl.style.top = `${y}px`; flashEl.style.opacity = '1'; flashEl.style.transform = 'translate(-50%, -50%) scale(1.5)'; setTimeout(() => { flashEl.style.opacity = '0'; flashEl.style.transform = 'translate(-50%, -50%) scale(1)'; }, 50);
        }
        
        function addMoloch(amount) { gameState.moloch += amount; gameStats.totalMolochEarned += amount; updateUI(); checkAchievements(); }
        function openTradeModal() { isTrading = true; document.exitPointerLock(); document.getElementById('trade-modal').style.display = 'flex'; renderTradeItems(); }
        function closeTradeModal() { isTrading = false; document.getElementById('trade-modal').style.display = 'none'; document.body.requestPointerLock(); }
        function renderTradeItems() { 
            const list = document.getElementById('trade-list'); list.innerHTML = ''; 
            
            // [NEW] 스코프 업그레이드 상점
            const scopeHeader = document.createElement('h3');
            scopeHeader.style.color = '#00ff00';
            scopeHeader.style.fontSize = '16px';
            scopeHeader.style.marginTop = '0';
            scopeHeader.style.borderBottom = '1px solid #555';
            scopeHeader.style.paddingBottom = '5px';
            scopeHeader.textContent = '스코프 업그레이드';
            list.appendChild(scopeHeader);
            
            const scopeRow = document.createElement('div');
            scopeRow.className = 'trade-item';
            const scopeInfo = document.createElement('span');
            scopeInfo.className = 'trade-item-info';
            
            let nextScopeLevel = unlockedScopeIndex + 1;
            if (nextScopeLevel >= SCOPE_LEVELS.length) {
                scopeInfo.textContent = "스코프: 최대 레벨 도달";
                const maxBtn = document.createElement('button');
                maxBtn.className = 'sell-btn';
                maxBtn.disabled = true;
                maxBtn.textContent = '구매 불가';
                scopeRow.appendChild(scopeInfo);
                scopeRow.appendChild(maxBtn);
            } else {
                const nextMag = SCOPE_LEVELS[nextScopeLevel];
                // 가격 계산: 100 * (3 ^ nextScopeLevel) -> 0일때 100, 1일때 300, 2일때 900
                const price = 100 * Math.pow(3, nextScopeLevel);
                scopeInfo.textContent = `스코프 업그레이드 (${nextMag}배율 해금)`;
                
                const buyBtn = document.createElement('button');
                buyBtn.className = 'sell-btn';
                buyBtn.style.backgroundColor = '#2196F3';
                buyBtn.textContent = `구매 (-${price} 몰록)`;
                
                if (gameState.moloch < price) {
                    buyBtn.disabled = true;
                    buyBtn.textContent = '몰록 부족';
                    buyBtn.style.backgroundColor = '#555';
                }
                
                buyBtn.onclick = () => {
                    if (gameState.moloch >= price) {
                        addMoloch(-price);
                        unlockedScopeIndex++;
                        showChat('상인', `좋은 선택이야. 이제 ${nextMag}배율까지 쓸 수 있네.`);
                        updateScopeUI();
                        renderTradeItems();
                    }
                };
                scopeRow.appendChild(scopeInfo);
                scopeRow.appendChild(buyBtn);
            }
            list.appendChild(scopeRow);


            const ammoHeader = document.createElement('h3'); ammoHeader.style.color = '#ff6b6b'; ammoHeader.style.fontSize = '16px'; ammoHeader.style.marginTop = '20px'; ammoHeader.style.borderBottom = '1px solid #555'; ammoHeader.style.paddingBottom = '5px'; ammoHeader.textContent = '탄약 판매 (내 물건 팔기)'; list.appendChild(ammoHeader); for (const [type, amount] of Object.entries(gameState.ammoInventory)) { const price = ammoPrices[type] || 10; const row = document.createElement('div'); row.className = 'trade-item'; const info = document.createElement('span'); info.className = 'trade-item-info'; info.textContent = `${type}: ${amount}발 보유`; const btn = document.createElement('button'); btn.className = 'sell-btn'; btn.textContent = `10발 판매 (+${price} 몰록)`; if (amount < 10) { btn.disabled = true; btn.textContent = '수량 부족'; } btn.onclick = () => { if (gameState.ammoInventory[type] >= 10) { gameState.ammoInventory[type] -= 10; addMoloch(price); showChat('상인', `${type} 10발을 ${price} 몰록에 샀네.`); renderTradeItems(); updateUI(); } }; row.appendChild(info); row.appendChild(btn); list.appendChild(row); } const ammoBuyHeader = document.createElement('h3'); ammoBuyHeader.style.color = '#4ecdc4'; ammoBuyHeader.style.fontSize = '16px'; ammoBuyHeader.style.marginTop = '20px'; ammoBuyHeader.style.borderBottom = '1px solid #555'; ammoBuyHeader.style.paddingBottom = '5px'; ammoBuyHeader.textContent = '탄약 구매 (상인 물건 사기)'; list.appendChild(ammoBuyHeader); for (const type of Object.keys(gameState.ammoInventory)) { const sellPrice = ammoPrices[type] || 10; const buyPrice = sellPrice * 3; const row = document.createElement('div'); row.className = 'trade-item'; const info = document.createElement('span'); info.className = 'trade-item-info'; info.textContent = `${type} (10발)`; const btn = document.createElement('button'); btn.className = 'sell-btn'; btn.style.backgroundColor = '#2196F3'; btn.textContent = `구매 (-${buyPrice} 몰록)`; if (gameState.moloch < buyPrice) { btn.disabled = true; btn.textContent = '몰록 부족'; btn.style.backgroundColor = '#555'; } btn.onclick = () => { if (gameState.moloch >= buyPrice) { addMoloch(-buyPrice); gameState.ammoInventory[type] += 10; showChat('상인', `여기 ${type} 10발일세. 아껴 쓰게나.`); renderTradeItems(); updateUI(); } }; row.appendChild(info); row.appendChild(btn); list.appendChild(row); } const weaponHeader = document.createElement('h3'); weaponHeader.style.color = '#ff6b6b'; weaponHeader.style.fontSize = '16px'; weaponHeader.style.marginTop = '20px'; weaponHeader.style.borderBottom = '1px solid #555'; weaponHeader.style.paddingBottom = '5px'; weaponHeader.textContent = '무기 판매'; list.appendChild(weaponHeader); let sellableWeaponsCount = 0; gameState.weapons.forEach((weapon, index) => { if (weapon.key === 'Fist') return; sellableWeaponsCount++; const weaponData = WEAPON_DATABASE[weapon.key]; const price = weaponPrices[weapon.key] || 100; const row = document.createElement('div'); row.className = 'trade-item'; const info = document.createElement('span'); info.className = 'trade-item-info'; let nameText = `${weaponData.name}`; if (index === gameState.currentWeaponIndex) { nameText += ` (장착 중)`; info.style.color = '#ffff00'; } info.textContent = nameText; const btn = document.createElement('button'); btn.className = 'sell-btn'; btn.style.backgroundColor = '#ff9800'; btn.textContent = `판매 (+${price} 몰록)`; btn.onclick = () => { addMoloch(price); showChat('상인', `${weaponData.name}을(를) ${price} 몰록에 매입하지.`); if (index === gameState.currentWeaponIndex) { switchWeapon(0); } else if (index < gameState.currentWeaponIndex) { gameState.currentWeaponIndex--; } gameState.weapons.splice(index, 1); renderTradeItems(); updateUI(); }; row.appendChild(info); row.appendChild(btn); list.appendChild(row); }); if (sellableWeaponsCount === 0) { const emptyMsg = document.createElement('div'); emptyMsg.style.padding = '10px'; emptyMsg.style.color = '#aaa'; emptyMsg.style.fontSize = '14px'; emptyMsg.textContent = '판매할 무기가 없습니다.'; list.appendChild(emptyMsg); } const weaponBuyHeader = document.createElement('h3'); weaponBuyHeader.style.color = '#4ecdc4'; weaponBuyHeader.style.fontSize = '16px'; weaponBuyHeader.style.marginTop = '20px'; weaponBuyHeader.style.borderBottom = '1px solid #555'; weaponBuyHeader.style.paddingBottom = '5px'; weaponBuyHeader.textContent = '무기 구매'; list.appendChild(weaponBuyHeader); for (const key in WEAPON_DATABASE) { if (key === 'Fist') continue; const weaponData = WEAPON_DATABASE[key]; const sellPrice = weaponPrices[key] || 100; const buyPrice = sellPrice * 3; const row = document.createElement('div'); row.className = 'trade-item'; const isOwned = gameState.weapons.find(w => w.key === key); const info = document.createElement('span'); info.className = 'trade-item-info'; info.textContent = weaponData.name; if (isOwned) { info.textContent += " (보유중)"; info.style.color = "#aaa"; } const btn = document.createElement('button'); btn.className = 'sell-btn'; btn.style.backgroundColor = '#2196F3'; btn.textContent = `구매 (-${buyPrice} 몰록)`; if (gameState.moloch < buyPrice) { btn.disabled = true; btn.textContent = '몰록 부족'; btn.style.backgroundColor = '#555'; } btn.onclick = () => { if (gameState.moloch >= buyPrice) { addMoloch(-buyPrice); if (isOwned) { showChat('상인', `이미 ${weaponData.name}이 있구만. 탄약만 챙겨주지.`); if (weaponData.ammoType) { gameState.ammoInventory[weaponData.ammoType] += weaponData.magSize; } } else { showChat('상인', `좋은 선택이야. ${weaponData.name}은(는) 아주 쓸만하지.`); gameState.weapons.push({ key: key, magAmmo: 0 }); if (weaponData.ammoType) { gameState.ammoInventory[weaponData.ammoType] += weaponData.magSize; } } renderTradeItems(); updateUI(); } }; row.appendChild(info); row.appendChild(btn); list.appendChild(row); } }

        function performPunch(weaponData) {
            let damage = weaponData.damage; 
            if (weaponData.type === 'Melee') {
                damage += (gameState.stats.strength * 2);
            }
            
            const range = weaponData.range; const direction = new THREE.Vector3(); camera.getWorldDirection(direction); raycaster.set(gameState.position, direction); raycaster.far = range; const allHits = raycaster.intersectObjects([...rangedEnemies, ...zombies, ...bosses], true); if (allHits.length === 0) return; let closestHit = null; for (const hit of allHits) { if (!closestHit || hit.distance < closestHit.distance) { closestHit = hit; } } if (!closestHit) return; if (playerGun && playerGun.userData.type === 'Melee') { if (playerGun.userData.isAnimating) return; playerGun.userData.isAnimating = true; const originalPos = { y: -0.3, z: -0.8 }; const punchY = originalPos.y + 0.1; const punchZ = originalPos.z - 0.2; playerGun.position.y = punchY; setTimeout(() => { if(playerGun && playerGun.userData.type === 'Melee') { playerGun.position.z = punchZ; } setTimeout(() => { if(playerGun && playerGun.userData.type === 'Melee') { playerGun.position.y = originalPos.y; playerGun.position.z = originalPos.z; playerGun.userData.isAnimating = false; } }, 50); }, 100); }
            let target = closestHit.object; while (target.parent && target.parent !== scene) { target = target.parent; }
            
            // [MODIFIED] 플레이어 공격 시 hitZombie 호출 (attacker = null은 플레이어 의미)
            if (target.userData.type === 'zombie') { hitZombie(target, damage, null); } 
            else if (target.userData.type === 'enemy') { 
                const enemy = target; if (!enemy.parent || enemy.userData.health <= 0) return; enemy.userData.health -= damage; showDamage(enemy.position, damage); const healthPercent = Math.max(0, enemy.userData.health / enemy.userData.maxHealth); enemy.material.color.copy(enemy.userData.originalColor).lerp(new THREE.Color(0xffffff), 1 - healthPercent); 
                if (enemy.userData.health > 0) { 
                    enemy.userData.state = 'chase'; 
                    // 플레이어가 때렸으니 플레이어 위치 기억
                    const targetPos = playerInVehicle ? playerInVehicle.position : gameState.position; 
                    enemy.userData.lastKnownPlayerPosition.copy(targetPos); 
                    // 적도 맞으면 customTarget을 플레이어로 재설정 (혹시 다른 몹이랑 싸우고 있었을 수도 있으니까)
                    enemy.userData.customTarget = null;
                } 
                if (enemy.userData.health <= 0) { addMoloch(Math.floor(Math.random() * 6) + 5); gainXP(50); if (Math.random() < 0.5) { const weaponKey = enemy.userData.weapon; const enemyWeaponData = WEAPON_DATABASE[weaponKey]; spawnItem({ type: 'weapon', name: weaponKey }, enemy.position.x, enemy.position.y, enemy.position.z); const multiplier = Math.floor(Math.random() * 2) + 1; const ammoData = { type: 'item', name: '탄약', subtype: enemyWeaponData.ammoType, amount: enemyWeaponData.magSize * multiplier }; spawnItem(ammoData, enemy.position.x + 0.5, enemy.position.y, enemy.position.z); } createDebrisEffect(enemy.position, enemy.material.color); scene.remove(enemy); rangedEnemies.splice(rangedEnemies.indexOf(enemy), 1); } 
            }
            else if (target.userData.type === 'boss') { target.userData.health -= damage; showDamage(target.position, damage); }
        }

        // [FIXED] 중복 및 문법 오류 수정
        function rangedEnemyShoot(enemy) { 
            const bullet = new THREE.Mesh(sharedBulletGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 })); 
            const targetPos = playerInVehicle ? playerInVehicle.position.clone().add(new THREE.Vector3(0, 1, 0)) : gameState.position.clone().add(new THREE.Vector3(0, -0.5, 0)); 
            const weaponKey = enemy.userData.weapon; 
            const weaponData = WEAPON_DATABASE[weaponKey]; 
            let baseError = ((5.0 + Math.random() * 15.0) * 0.5) * 0.7; 
            if (weaponData.type === 'SR' || weaponData.type === 'DMR') { baseError *= 0.5; } 
            const accuracyError = baseError; 
            targetPos.x += (Math.random() - 0.5) * accuracyError; 
            targetPos.y += (Math.random() - 0.5) * accuracyError; 
            targetPos.z += (Math.random() - 0.5) * accuracyError; 
            const firePosition = new THREE.Vector3(); 
            enemy.userData.muzzle.getWorldPosition(firePosition); 
            const direction = new THREE.Vector3().subVectors(targetPos, firePosition).normalize(); 
            bullet.position.copy(firePosition); 
            // [MODIFIED] 총알에 발사한 주인(enemy) 정보를 ownerRef로 확실히 전달
            bullet.userData = { velocity: direction, spawnPosition: bullet.position.clone(), weaponKey: enemy.userData.weapon, owner: 'enemy', ownerRef: enemy }; 
            scene.add(bullet); 
            bullets.push(bullet); 
        }

        function interact() {
            if (playerInVehicle) { toggleVehicle(playerInVehicle); return; }
            if (interactableObject) { const { type } = interactableObject.userData; if (type === 'item' || type === 'weapon' || type === 'scope') { pickupItem(interactableObject); } else if (type === 'npc') { const data = interactableObject.userData; if (data.name === '상인') { openTradeModal(); } else if (data.name === '생존자') { const claimable = achievements.filter(ach => ach.unlocked && !ach.claimed); if (claimable.length > 0) { const ach = claimable[0]; ach.claimed = true; addMoloch(ach.reward); showChat('생존자', `오! '${ach.title}' 업적을 달성했군. 여기 보상일세.`); showChat('시스템', `도전과제 보상: ${ach.reward} 몰록 획득!`); return; } 
            
            // [MODIFIED] 첫 번째 퀘스트 완료 및 설명 대화 추가
            if (questState.type === 'talk_survivor' && questState.status === 1) {
                addMoloch(questState.rewardMoloch);
                showChat('시스템', `퀘스트 완료: 생존자와 대화 (+${questState.rewardMoloch} 몰록)`);
                showChat('생존자', "반갑네. 빈손으로 보내긴 뭐하니 이거라도 받게.");
                
                // 퀘스트 상태를 잠시 대기(설명 듣는 중)로 변경
                questState = { status: 0, type: 'hunt_zombie', targetAmount: 1, currentAmount: 0, rewardMoloch: 500 };
                updateQuestUI(); // UI 갱신 (퀘스트 목록에서 잠시 사라짐)

                // [NEW] 종족별 특징 및 보스 설명 대화 체인 (색상 및 오크 중립 설명 추가)
                const explainDelay = 3500; // 읽을 시간을 위해 딜레이 약간 증가
                setTimeout(() => showChat('생존자', "이 세계에서 살아남으려면 적들의 색깔과 특징을 잘 기억해야 해."), explainDelay * 0.5);
                
                setTimeout(() => showChat('생존자', "🧟 [좀비]는 <span style='color:#00ff00'>초록색</span> 피부를 가졌어. 느리지만 떼로 덤비면 위험하니 머리를 노리게."), explainDelay * 1.5);
                
                setTimeout(() => showChat('생존자', "👹 [오크]는 <span style='color:#228B22'>진한 녹색</span>이고 군락을 이뤄 살지. 다행히 <span style='color:#ffff00'>중립적</span>이라 자네가 먼저 건드리지 않으면 공격하지 않을 걸세."), explainDelay * 2.5);
                
                setTimeout(() => showChat('생존자', "👺 [트롤]은 <span style='color:#2F4F2F'>어두운 쑥색</span> 거구야. 맷집이 좋고 재생 능력이 있어서 화력을 집중해야만 쓰러뜨릴 수 있어."), explainDelay * 3.5);
                
                setTimeout(() => showChat('생존자', "🧙‍♀️ [마녀] 보스는 <span style='color:#800080'>보라색</span> 옷을 입고 있어. 순간이동을 하고 하수인을 소환하니 아주 까다롭지."), explainDelay * 4.5);
                
                setTimeout(() => showChat('생존자', "🔥 [불의 악마]는 <span style='color:#ff4500'>붉게 타오르는</span> 거대한 보스야. 가까이 붙으면 충격파를 쓰니 거리를 벌려야 사네!"), explainDelay * 5.5);
                
                // 설명이 끝난 후 다음 퀘스트(좀비 사냥) 부여
                setTimeout(() => {
                    showChat('생존자', "설명은 이쯤 하고... 자네 실력을 좀 볼까?");
                    setTimeout(() => { 
                        showChat('생존자', "주변에 좀비가 너무 많아. 1마리만 처리해주면 보답하지."); 
                        questState.status = 1; // 퀘스트 활성화
                        questState.currentAmount = 0; 
                        updateQuestUI(); 
                    }, 2000);
                }, explainDelay * 6.5);
                return;
            }

            if (questState.status === 0) { 
                // 설명 듣는 도중 말을 걸었을 때
                showChat('생존자', "내 이야기를 잘 듣고 있게나. 아주 중요한 정보야."); 
            } else if (questState.status === 1) { showChat('생존자', `아직 부탁한 걸 다 못 끝낸 것 같군. 좀비 ${questState.targetAmount - questState.currentAmount}마리만 더 부탁해.`); } else if (questState.status === 2) { showChat('생존자', "오! 정말 대단하군. 덕분에 한시름 놓았어. 이건 약속한 보상일세."); addMoloch(questState.rewardMoloch); showChat('시스템', `퀘스트 완료 보상: ${questState.rewardMoloch} 몰록 획득!`); questState.status = 3; updateQuestUI(); } else if (questState.status === 3) { const dialogue = ["항상 주변을 조심하게.", "자네 덕분에 오늘 밤은 편히 잘 수 있겠어.", "더 필요한 게 있으면 상인을 찾아가보게.", "이 근처에서 업적을 쌓으면 내게 오게나."]; const rnd = Math.floor(Math.random() * dialogue.length); showChat('생존자', dialogue[rnd]); } } else { if (data.tutorialDialogue && data.tutorialIndex < data.tutorialDialogue.length) { showChat(data.name, data.tutorialDialogue[data.tutorialIndex]); data.tutorialIndex++; } else { const { dialogue, dialogueIndex, name } = data; showChat(name, dialogue[dialogueIndex]); interactableObject.userData.dialogueIndex = (dialogueIndex + 1) % dialogue.length; } } } else if (type === 'vehicle') { toggleVehicle(interactableObject); } }
        }
        
        // [MODIFIED] 퀘스트 UI 업데이트 함수 수정 (talk_survivor 타입 처리 추가)
        function updateQuestUI() { 
            const display = document.getElementById('quest-display'); 
            const objective = document.getElementById('quest-objective'); 
            
            if (questState.status === 0 || questState.status === 3) { 
                display.style.display = 'none'; 
            } else { 
                display.style.display = 'block'; 
                
                if (questState.type === 'talk_survivor') {
                    objective.innerHTML = "생존자와 대화하세요";
                    objective.className = 'quest-ready'; // 깜빡이는 효과
                } else if (questState.status === 1) { 
                    objective.innerHTML = `- 좀비 처치: <span style="color:#00ff00">${questState.currentAmount}</span> / ${questState.targetAmount}`; 
                    objective.className = ''; 
                } else if (questState.status === 2) { 
                    objective.innerHTML = "생존자에게 돌아가 보고하세요!"; 
                    objective.className = 'quest-ready'; 
                } 
            } 
        }
        function toggleVehicle(vehicle, isDestroyed = false) { if (playerInVehicle) { const rightDir = new THREE.Vector3(1, 0, 0).applyQuaternion(vehicle.quaternion); const exitPos = vehicle.position.clone().add(rightDir.multiplyScalar(2.0)); const exitY = getTerrainHeight(exitPos.x, exitPos.z) + 1.8; gameState.position.set(exitPos.x, exitY, exitPos.z); const vehicleRotationY = vehicle.rotation.y; gameState.rotation.y = vehicleRotationY; gameState.rotation.x = 0; scene.add(camera); camera.position.copy(gameState.position); camera.rotation.set(gameState.rotation.x, gameState.rotation.y, 0, 'YXZ'); playerGun.visible = true; playerInVehicle = null; if (isDestroyed) { gameState.health = Math.max(0, gameState.health - 25); showChat("시스템", "차량이 파괴되었습니다! 비상 탈출합니다!"); const newPlayerPos = gameState.position.clone(); [...zombies, ...rangedEnemies].forEach(enemy => { if (enemy.userData.health > 0) { enemy.userData.lastKnownPlayerPosition.copy(newPlayerPos); enemy.userData.state = 'chase'; } }); } else { showChat('시스템', '차량에서 하차했습니다.'); } } else { playerInVehicle = vehicle; vehicle.add(camera); camera.position.set(0, 1.2, -0.5); camera.rotation.set(0, 0, 0, 'YXZ'); playerGun.visible = false; showChat('시스템', `차량에 탑승했습니다.`); } updateUI(); }
        function pickupItem(item) { 
            const data = item.userData; 
            if (data.type === 'weapon') { 
                const weaponData = WEAPON_DATABASE[data.name]; const alreadyOwned = gameState.weapons.find(w => w.key === data.name); 
                if (!alreadyOwned) { gameState.weapons.push({ key: data.name, magAmmo: 0 }); if (weaponData.ammoType) { gameState.ammoInventory[weaponData.ammoType] = (gameState.ammoInventory[weaponData.ammoType] || 0) + (weaponData.magSize * 2); } showChat('시스템', `<span class="weapon-name-chat">${weaponData.name}</span>을(를) 획득했습니다.`); switchWeapon(gameState.weapons.length - 1); } 
                else { if (weaponData.ammoType) { gameState.ammoInventory[weaponData.ammoType] = (gameState.ammoInventory[weaponData.ammoType] || 0) + weaponData.magSize; showChat('시스템', `이미 소지한 무기입니다. <span class="item-name">${weaponData.ammoType}</span> ${weaponData.magSize}발을 획득합니다.`); } else { showChat('시스템', `이미 소지한 무기입니다.`); } } 
            } else if (data.type === 'scope') {
                if (data.level > unlockedScopeIndex) {
                    unlockedScopeIndex = data.level;
                    showChat('시스템', `<span style="color:#00ff00; font-weight:bold;">${data.name}</span>을(를) 획득하여 장착했습니다!`);
                    updateScopeUI();
                } else {
                    showChat('시스템', '이미 더 좋은 스코프를 가지고 있습니다.');
                }
            } else if (data.name === '탄약') { if (gameState.ammoInventory.hasOwnProperty(data.subtype)) { gameState.ammoInventory[data.subtype] += data.amount; showChat('시스템', `<span class="item-name">${data.subtype}</span> ${data.amount}발을 획득했습니다.`); } } 
            else if (data.name === '의료키트') { gameState.health = Math.min(getMaxHealth(), gameState.health + 500); showChat('시스템', `체력이 회복되었습니다!`); } 
            else if (data.name === '음식') { playerStamina = Math.min(getMaxStamina(), playerStamina + 50); showChat('시스템', `<span class="item-name">음식</span>으로 스태미나를 회복했습니다!`); } 
            else if (data.name === '에너지드링크') { playerStamina = Math.min(getMaxStamina(), playerStamina + 40); showChat('시스템', `<span class="item-name" style="color:#00ffff">에너지드링크</span>를 마셔 활력을 되찾았습니다!`); } 
            scene.remove(item); items = items.filter(i => i !== item); updateUI(); 
        }
        function showChat(name, message) { const chatBox = document.getElementById('chat-box'); const messageDiv = document.createElement('div'); messageDiv.className = 'chat-message'; let nameSpan; 
            if (name === '시스템') nameSpan = `<span class="system-name">${name}:</span>`; 
            else if (name === '좀비') nameSpan = `<span class="zombie-name">${name}:</span>`; 
            else if (name === '트롤') nameSpan = `<span style="color:#556B2F; font-weight:bold; font-size:1.1em;">${name}:</span>`; 
            else if (name === '불의 악마') nameSpan = `<span style="color:#ff4500; font-weight:bold;">${name}:</span>`; 
            else if (name === '저주받은 마녀') nameSpan = `<span style="color:#800080; font-weight:bold;">${name}:</span>`; 
            else if (name.includes('오크')) nameSpan = `<span style="color:#228B22; font-weight:bold;">${name}:</span>`; 
            else nameSpan = `<span class="npc-name">${name}:</span>`; 
            messageDiv.innerHTML = `${nameSpan} ${message}`; chatBox.appendChild(messageDiv); chatBox.style.display = 'flex'; while (chatBox.children.length > 5) { chatBox.removeChild(chatBox.firstChild); } setTimeout(() => { if (chatBox.contains(messageDiv)) { messageDiv.style.opacity = '0'; setTimeout(() => { if (chatBox.contains(messageDiv)) chatBox.removeChild(messageDiv); if (chatBox.children.length === 0) chatBox.style.display = 'none'; }, 500); } }, 5000); }
        function updateInteraction() {
            if (isPointerLocked === false || playerInVehicle || isTrading || isStatsOpen) { document.getElementById('interaction-prompt').style.display = 'none'; interactableObject = null; return; }
            const range = 3.5; let closestObject = null; let minDistance = range; const checkableObjects = [...items, ...vehicles, ...npcs]; checkableObjects.forEach(obj => { const dist = gameState.position.distanceTo(obj.position); if (dist < minDistance) { minDistance = dist; closestObject = obj; } });
            if (closestObject) { const direction = closestObject.position.clone().sub(gameState.position).normalize(); raycaster.set(gameState.position, direction); raycaster.far = range; const intersects = raycaster.intersectObjects([closestObject], true); if (intersects.length > 0 && intersects[0].object) { let target = intersects[0].object; while (target.parent && target.parent !== scene) { target = target.parent; } if (target.userData.type && (target.userData.type === 'item' || target.userData.type === 'weapon' || target.userData.type === 'scope' || target.userData.type === 'vehicle' || target.userData.type === 'npc')) { interactableObject = target; } else { interactableObject = null; } } else { interactableObject = null; } } else { interactableObject = null; }
            const prompt = document.getElementById('interaction-prompt'); const itemNameEl = document.getElementById('interaction-item-name'); const actionEl = document.getElementById('interaction-action');
            if (interactableObject) { let action = "줍기"; let itemName = interactableObject.userData.name || interactableObject.userData.type; if (interactableObject.userData.type === 'vehicle') { action = "탑승"; itemName = "차량"; } else if (interactableObject.userData.type === 'npc') { action = "대화"; itemName = interactableObject.userData.name; if (itemName === '상인') { action = "거래"; } else if (itemName === '생존자') { const hasClaimable = achievements.some(a => a.unlocked && !a.claimed); if (hasClaimable) { action = "보상 수령"; } } } else if (interactableObject.userData.type === 'weapon') { action = "줍기"; itemName = WEAPON_DATABASE[interactableObject.userData.name].name; } else if (interactableObject.userData.type === 'scope') { action = "장착"; } else if (interactableObject.userData.name === '탄약') { action = "줍기"; itemName = `${interactableObject.userData.subtype} ${interactableObject.userData.amount}발`; } else if (interactableObject.userData.name === '의료키트') { action = "사용"; itemName = `의료키트`; } else if (interactableObject.userData.name === '에너지드링크') { action = "마시기"; itemName = `에너지드링크`; } itemNameEl.textContent = itemName; actionEl.textContent = action; prompt.style.display = 'block'; } else { prompt.style.display = 'none'; }
        }

        function updateUI() {
            document.getElementById('moloch-count').textContent = gameState.moloch;
            const maxHealth = getMaxHealth();
            const maxStamina = getMaxStamina();
            const healthPercent = (gameState.health / maxHealth) * 100; document.getElementById('health-fill').style.width = `${healthPercent}%`; document.getElementById('health-text').textContent = `${Math.floor(gameState.health)} / ${maxHealth}`;
            const staminaPercent = (playerStamina / maxStamina) * 100; document.getElementById('stamina-fill').style.width = `${staminaPercent}%`; document.getElementById('stamina-text').textContent = `${Math.floor(playerStamina)} / ${maxStamina}`;
            document.getElementById('level-badge').textContent = gameState.level;
            const xpPercent = (gameState.xp / gameState.xpToNextLevel) * 100;
            document.getElementById('xp-fill').style.width = `${xpPercent}%`;
            if (playerStamina < JUMP_STAMINA_COST) { document.getElementById('stamina-fill').style.background = '#FF4136'; } else { document.getElementById('stamina-fill').style.background = '#2196F3'; }
            const vehicleStatusRow = document.getElementById('vehicle-status-row'); if (playerInVehicle) { const vh = playerInVehicle.userData; const vhPercent = (vh.health / vh.maxHealth) * 100; document.getElementById('vehicle-health-fill').style.width = `${vhPercent}%`; document.getElementById('vehicle-health-text').textContent = `${Math.floor(vh.health)} / ${vh.maxHealth}`; vehicleStatusRow.style.display = 'flex'; } else { vehicleStatusRow.style.display = 'none'; }
            const weaponObj = gameState.weapons[gameState.currentWeaponIndex]; if (weaponObj) { const weaponData = WEAPON_DATABASE[weaponObj.key]; const ammoType = weaponData.ammoType; const inventoryAmmo = ammoType ? (gameState.ammoInventory[ammoType] || 0) : 0; document.getElementById('current-ammo').textContent = weaponObj.magAmmo; document.getElementById('ammo-total').textContent = ammoType ? inventoryAmmo : '—'; document.getElementById('weapon-name').textContent = weaponData.name; if (ammoType && weaponObj.magAmmo === 0 && inventoryAmmo > 0 && !gameState.isReloading) { document.getElementById('reload-prompt').style.display = 'block'; } else { document.getElementById('reload-prompt').style.display = 'none'; } } else { document.getElementById('current-ammo').textContent = '-'; document.getElementById('ammo-total').textContent = '-'; document.getElementById('weapon-name').textContent = '맨손'; document.getElementById('reload-prompt').style.display = 'none'; }
            const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position; const displayX = Math.round(playerPos.x); const displayY = Math.round(playerPos.z); document.getElementById('coord-display').innerHTML = `X: ${displayX}, Y: ${displayY} <span style="font-size:0.8em; color:#ccc; margin-left:10px;" id="biome-display">[${getBiome(playerPos.x, playerPos.z).toUpperCase()}]</span>`;
        }
        
        // [OPTIMIZATION] 청크 기반 충돌 검사
        function getNearbyStaticObjects(pos) {
            const nearby = [];
            const chunkX = Math.round(pos.x / CHUNK_SIZE);
            const chunkZ = Math.round(pos.z / CHUNK_SIZE);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    const key = `${chunkX + dx},${chunkZ + dz}`;
                    if (chunkStaticObjects.has(key)) {
                        nearby.push(...chunkStaticObjects.get(key));
                    }
                }
            }
            return nearby;
        }

        function updatePlayer(delta) {
            // [NEW] 엔딩 시퀀스 처리 (승천)
            if (gameState.isEnding) {
                // 중력 무시, 조작 무시, 위로 상승
                gameState.position.y += delta * 20.0; // 초당 20m 상승
                
                // 시선 강제 고정 (위쪽 혹은 아래쪽) - 여기선 아래를 내려다보게 처리
                camera.rotation.x = -Math.PI / 2.5; 
                
                // 카메라 업데이트
                camera.position.copy(gameState.position);
                updateUI();
                
                // 1000m 도달 시 엔딩 화면 출력
                if (gameState.position.y >= 1000) {
                    showEndingScreen();
                }
                return; // 이후 물리/이동 로직 스킵
            }

            const maxStamina = getMaxStamina();
            const maxHealth = getMaxHealth();
            if (!playerInVehicle && controls.sprint && (controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight)) { if (playerStamina > STAMINA_THRESHOLD) { playerStamina = Math.max(0, playerStamina - STAMINA_DRAIN_RATE * delta); } else { controls.sprint = false; } } else { playerStamina = Math.min(maxStamina, playerStamina + STAMINA_RECOVERY_RATE * delta); }
            if (playerStamina >= (maxStamina * 0.9) && gameState.health < maxHealth) { const healthRegenRate = 1 / 3; const healAmount = healthRegenRate * delta; gameState.health += healAmount; playerStamina -= healAmount * 4; if (gameState.health > maxHealth) { gameState.health = maxHealth; } }
            if (playerInVehicle) return;
            const baseSpeed = getMoveSpeed(); 
            const sprintMultiplier = 1.4; const gravity = 0.015; const jumpForce = 0.3; const playerHeight = 1.8;
            const currentSpeed = (controls.sprint && playerStamina > STAMINA_THRESHOLD) ? baseSpeed * sprintMultiplier : baseSpeed; const moveSpeed = currentSpeed * delta;
            const terrainFloor = getTerrainHeight(gameState.position.x, gameState.position.z);
            
            // [OPTIMIZATION] 레이캐스트 범위 제한 및 대상 최적화
            // 지면 확인은 그대로 objects 전체 (PlaneGeometry는 갯수가 적음)
            // 지형 + 바닥 확인
            raycaster.set(gameState.position.clone().add(new THREE.Vector3(0, 1.0, 0)), new THREE.Vector3(0, -1, 0)); raycaster.far = 20.0; 
            
            // [OPTIMIZATION] 플레이어 발밑 근처 정적 오브젝트만 검사
            const nearbyObjects = getNearbyStaticObjects(gameState.position);
            // 지형(Plane)은 전역 objects에서 필터링하거나, 구조(structures) 배열 사용
            const checkList = [...nearbyObjects, ...structures]; 

            const intersects = raycaster.intersectObjects(checkList, true); let objectFloor = -Infinity; let onObject = false;
            const validGroundHitPlayer = intersects.find(hit => hit.object.geometry.type === 'PlaneGeometry' || hit.object.userData.type === 'roof' || hit.object.userData.type === 'floor' || hit.object.userData.type === 'object' || hit.object.userData.type === 'lava');
            if (validGroundHitPlayer) { if (validGroundHitPlayer.object.geometry.type !== 'PlaneGeometry') { objectFloor = validGroundHitPlayer.point.y; onObject = true; } if (validGroundHitPlayer.object.userData.isHighrise) { gameState.inHighrise = true; } else { gameState.inHighrise = false; } }
            let groundLevel = terrainFloor; if (onObject && objectFloor > terrainFloor) { groundLevel = objectFloor; }
            if (gameState.position.y <= groundLevel + playerHeight + 0.2 && gameState.velocityY <= 0) { if (!gameState.onGround) { gameState.velocityY = 0; } gameState.onGround = true; gameState.position.y = groundLevel + playerHeight; } else { gameState.onGround = false; }
            if (!gameState.onGround) { gameState.velocityY -= gravity; }
            
            // [FIX] 용암 데미지 판정 범위 수정 (접촉 시 즉시 데미지)
            // 기존: gameState.position.y - 1.5 (가슴 높이) < lavaHeight
            // 수정: gameState.position.y - 1.8 (발바닥 높이) <= lavaHeight + 0.2 (살짝 위까지)
            const lavaHeight = getLavaHeight(gameState.position.x, gameState.position.z);
            if (gameState.position.y - 1.8 <= lavaHeight + 0.2) { 
                const damage = 20 * delta; 
                gameState.health -= damage; 
                showLavaDamageEffect(); 
                if (gameState.health <= 0) handleGameOver(); 
            }

            if (controls.jump && gameState.onGround) { if (playerStamina > STAMINA_THRESHOLD && playerStamina >= JUMP_STAMINA_COST) { gameState.velocityY = jumpForce; playerStamina -= JUMP_STAMINA_COST; gameState.onGround = false; } else { if (playerStamina <= STAMINA_THRESHOLD) { showChat('시스템', '지쳐서 점프할 수 없습니다. (스태미나 5 이하)'); } else { showChat('시스템', '스태미나가 부족하여 점프할 수 없습니다.'); } } controls.jump = false; }
            gameState.position.y += gameState.velocityY;
            const safeFloor = Math.max(terrainFloor, (getBiome(gameState.position.x, gameState.position.z) === 'volcano' ? LAVA_LEVEL : -100));
            if (gameState.position.y < safeFloor + playerHeight) { gameState.position.y = safeFloor + playerHeight; gameState.velocityY = 0; gameState.onGround = true; }
            if (gameState.position.y < -50) { gameState.health = 0; handleGameOver(); return; }
            const direction = new THREE.Vector3(); if (controls.moveForward) direction.z -= 1; if (controls.moveBackward) direction.z += 1; if (controls.moveLeft) direction.x -= 1; if (controls.moveRight) direction.x += 1;
            if (direction.length() > 0) { direction.normalize().applyEuler(new THREE.Euler(0, gameState.rotation.y, 0, 'YXZ')); const velocity = direction.multiplyScalar(moveSpeed); const oldPosition = gameState.position.clone();
                const TERRAIN_COLLISION_RADIUS = 0.5; const MAX_SLOPE_HEIGHT = 1.0; const PUSH_BACK_FORCE = 0.1; const horizontalCollider = new THREE.Box3(new THREE.Vector3(-0.3, -playerHeight + 0.1, -0.3), new THREE.Vector3(0.3, (playerHeight / 2) - 0.2, 0.3));
                if (Math.abs(velocity.x) > 0.0001) { const nextX = gameState.position.x + velocity.x; const dirX = Math.sign(velocity.x); const probeX = nextX + (dirX * TERRAIN_COLLISION_RADIUS); const probeY = getTerrainHeight(probeX, gameState.position.z); if (probeY - terrainFloor > MAX_SLOPE_HEIGHT) { velocity.x = 0; gameState.position.x -= dirX * PUSH_BACK_FORCE; } } gameState.position.x += velocity.x;
                
                // [OPTIMIZATION] 충돌 검사 범위 축소 (nearbyObjects)
                let playerWorldCollider = horizontalCollider.clone().translate(gameState.position); 
                for (const object of nearbyObjects) { 
                    const distSq = gameState.position.distanceToSquared(object.position); 
                    // [FIX] 건물 통과 버그 수정: 거리 체크 범위를 50(7m)에서 COLLISION_CHECK_DISTANCE_SQ(50m)로 증가
                    // 건물의 중심점이 멀더라도 벽은 가까울 수 있으므로 넉넉하게 체크해야 함
                    if (distSq > COLLISION_CHECK_DISTANCE_SQ) continue; 
                    
                    if (!object.geometry || !object.parent || object.userData.type === 'roof' || object.geometry.type === 'PlaneGeometry' || object.userData.type === 'lava') { continue; } 
                    if (!object.geometry.boundingBox) object.geometry.computeBoundingBox(); 
                    const objectBox = tempBox.setFromObject(object); // 재사용 박스
                    if (playerWorldCollider.intersectsBox(objectBox)) { gameState.position.x = oldPosition.x; break; } 
                }

                if (Math.abs(velocity.z) > 0.0001) { const nextZ = gameState.position.z + velocity.z; const dirZ = Math.sign(velocity.z); const probeZ = nextZ + (dirZ * TERRAIN_COLLISION_RADIUS); const probeY = getTerrainHeight(gameState.position.x, probeZ); const currentFloorZ = getTerrainHeight(gameState.position.x, gameState.position.z); if (probeY - currentFloorZ > MAX_SLOPE_HEIGHT) { velocity.z = 0; gameState.position.z -= dirZ * PUSH_BACK_FORCE; } } gameState.position.z += velocity.z;
                
                playerWorldCollider = horizontalCollider.clone().translate(gameState.position); 
                for (const object of nearbyObjects) { 
                    const distSq = gameState.position.distanceToSquared(object.position); 
                    // [FIX] Z축 이동 시에도 동일하게 거리 체크 수정
                    if (distSq > COLLISION_CHECK_DISTANCE_SQ) continue; 
                    
                    if (!object.geometry || !object.parent || object.userData.type === 'roof' || object.geometry.type === 'PlaneGeometry' || object.userData.type === 'lava') { continue; } 
                    if (!object.geometry.boundingBox) object.geometry.computeBoundingBox(); 
                    const objectBox = tempBox.setFromObject(object); 
                    if (playerWorldCollider.intersectsBox(objectBox)) { gameState.position.z = oldPosition.z; break; } 
                }
            }
            const stuckCollider = new THREE.Box3(new THREE.Vector3(-0.2, -playerHeight + 0.5, -0.2), new THREE.Vector3(0.2, 0.0, 0.2)).translate(gameState.position); let isStuck = false; 
            for (const object of nearbyObjects) { 
                if (!object.geometry || !object.parent || object.userData.type === 'roof' || object.userData.type === 'floor' || object.userData.type === 'teleporter' || object.userData.type === 'lava' || object.geometry.type === 'PlaneGeometry') { continue; } 
                // [FIX] 끼임 감지(Stuck) 체크 거리도 동일하게 증가
                if (gameState.position.distanceToSquared(object.position) > COLLISION_CHECK_DISTANCE_SQ) continue; 
                
                if (!object.geometry.boundingBox) object.geometry.computeBoundingBox(); 
                const objectBox = tempBox.setFromObject(object); 
                if (stuckCollider.intersectsBox(objectBox)) { isStuck = true; break; } 
            }
            if (isStuck) { gameState.position.y += 7.0; gameState.velocityY = 0; }
            const playerCollider = new THREE.Box3(new THREE.Vector3(-0.4, -playerHeight, -0.4), new THREE.Vector3(0.4, 0.1, 0.4)).translate(gameState.position); for (const trigger of stairTriggers) { const triggerBox = new THREE.Box3().setFromObject(trigger); if(playerCollider.intersectsBox(triggerBox)) { gameState.position.copy(trigger.userData.targetPosition); gameState.velocityY = 0; break; } }
            
            // [수정] 줌 기능: FOV 조절
            if (isAiming) {
                const targetFOV = BASE_FOV / currentZoomLevel;
                camera.fov = THREE.MathUtils.lerp(camera.fov, targetFOV, delta * 10);
            } else {
                camera.fov = THREE.MathUtils.lerp(camera.fov, BASE_FOV, delta * 10);
            }
            camera.updateProjectionMatrix();
            
            camera.position.copy(gameState.position); camera.rotation.set(gameState.rotation.x, gameState.rotation.y, 0, 'YXZ'); updateUI();
        }
        
        function updateVehicles(delta) {
            const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position;
            // [OPTIMIZATION] 주변 정적 오브젝트
            const nearbyObjects = getNearbyStaticObjects(playerPos);

            for(let i = vehicles.length -1; i >= 0; i--) {
                const vehicleA = vehicles[i]; if (!vehicleA.parent) continue; if (playerInVehicle !== vehicleA) { const distSq = vehicleA.position.distanceToSquared(playerPos); if (distSq > ACTIVE_RADIUS_SQ) { vehicleA.visible = false; continue; } vehicleA.visible = true; }
                for(let j = i - 1; j >= 0; j--) { const vehicleB = vehicles[j]; if (!vehicleB.parent) continue; if (vehicleA.position.distanceToSquared(vehicleB.position) > 100) continue; const boxA = vehicleA.userData.collisionBox.clone().translate(vehicleA.position); const boxB = vehicleB.userData.collisionBox.clone().translate(vehicleB.position); if(boxA.intersectsBox(boxB)) { const relativeSpeed = Math.abs(vehicleA.userData.speed) + Math.abs(vehicleB.userData.speed); const damage = relativeSpeed * 30 * 0.625; vehicleA.userData.health -= damage; vehicleB.userData.health -= damage; const tempSpeed = vehicleA.userData.speed; vehicleA.userData.speed = vehicleB.userData.speed * -0.5; vehicleB.userData.speed = tempSpeed * -0.5; } }
                if (playerInVehicle === vehicleA) {
                    const data = vehicleA.userData; data.steering = THREE.MathUtils.lerp(data.steering, vehicleSteering, delta * 5); const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(vehicleA.quaternion).normalize(); const samplePos = vehicleA.position.clone().add(forwardDir.clone().multiplyScalar(2.0)); const currentH = getTerrainHeight(vehicleA.position.x, vehicleA.position.z); const nextH = getTerrainHeight(samplePos.x, samplePos.z); 
                    const slope = nextH - currentH; const gravityFactor = 15.0; const gravityResistance = slope * gravityFactor * delta; 
                    data.speed -= gravityResistance; if (vehicleAcceleration > 0) { data.speed = Math.min(data.maxSpeed, data.speed + data.acceleration * delta); } else if (vehicleAcceleration < 0) { data.speed -= (data.speed > 0 ? data.braking : data.acceleration) * delta; } else { data.speed = THREE.MathUtils.lerp(data.speed, 0, delta * data.friction); } const turnFactor = Math.min(1, Math.abs(data.speed) / (data.maxSpeed * 0.5)); vehicleA.rotation.y -= data.steering * data.turnSpeed * turnFactor * delta; const moveDirection = new THREE.Vector3(0, 0, 1).applyQuaternion(vehicleA.quaternion); const displacement = moveDirection.multiplyScalar(data.speed * delta); const oldPosition = vehicleA.position.clone(); vehicleA.position.add(displacement); const terrainY = getTerrainHeight(vehicleA.position.x, vehicleA.position.z); const targetY = terrainY + 0.4; vehicleA.position.y = THREE.MathUtils.lerp(vehicleA.position.y, targetY, delta * 10); if (vehicleA.position.y < targetY) { vehicleA.position.y = targetY; } camera.rotation.set(gameState.rotation.x, 0, 0, 'YXZ'); gameState.position.copy(camera.getWorldPosition(new THREE.Vector3())); gameState.rotation.y = vehicleA.rotation.y; 
                    const vehicleBox = vehicleA.userData.collisionBox.clone().translate(vehicleA.position); const oldSpeed = data.speed; 
                    const speedAbs = Math.abs(data.speed);
                    if (speedAbs > 2.0) { 
                        const enemies = [...zombies, ...rangedEnemies];
                        for (let k = enemies.length - 1; k >= 0; k--) {
                            const enemy = enemies[k];
                            if (!enemy.parent || enemy.userData.health <= 0) continue;
                            if (vehicleA.position.distanceToSquared(enemy.position) > 36) continue; 
                            const enemyBox = new THREE.Box3().setFromObject(enemy);
                            if (vehicleBox.intersectsBox(enemyBox)) {
                                const damage = speedAbs * 80; createDebrisEffect(enemy.position, new THREE.Color(0xaa0000), 10); showDamage(enemy.position, damage, '#ff0000'); gameStats.roadKills++; checkAchievements();
                                if (enemy.userData.type === 'zombie') { hitZombie(enemy, damage); if (enemy.userData.health <= 0) showChat('시스템', '로드킬! (좀비 처치)'); } else if (enemy.userData.type === 'enemy') { enemy.userData.health -= damage; if (enemy.userData.health <= 0) { showChat('시스템', '로드킬! (적 처치)'); createDebrisEffect(enemy.position, enemy.material.color); scene.remove(enemy); rangedEnemies.splice(rangedEnemies.indexOf(enemy), 1); addMoloch(20); } else { enemy.userData.state = 'chase'; } }
                                data.speed *= 0.8; vehicleA.userData.health -= 10;
                            }
                        }
                    }
                    // [OPTIMIZATION] 차량 충돌도 nearbyObjects 사용
                    for (const object of nearbyObjects) { const distSq = vehicleA.position.distanceToSquared(object.position); if (distSq > COLLISION_CHECK_DISTANCE_SQ) continue; if (!object.geometry || !object.parent || object.geometry.type === 'PlaneGeometry' || object.userData.type === 'roof' || object.userData.type === 'lava') continue; if (!object.geometry.boundingBox) object.geometry.computeBoundingBox(); const objectBox = tempBox.setFromObject(object); if (vehicleBox.intersectsBox(objectBox)) { vehicleA.position.copy(oldPosition); const damage = Math.abs(oldSpeed) * 40 * 0.31; vehicleA.userData.health -= damage; vehicleA.userData.speed *= -0.5; break; } }
                } else { raycaster.set(vehicleA.position.clone().add(new THREE.Vector3(0, 1, 0)), new THREE.Vector3(0, -1, 0)); const vehicleIntersects = raycaster.intersectObjects(objects, true); let vehicleGroundY = vehicleA.position.y; if (vehicleIntersects.length > 0) { const firstHit = vehicleIntersects.find(hit => hit.object.geometry.type === 'PlaneGeometry' || hit.object.userData.type === 'roof' || hit.object.userData.type === 'floor' || hit.object.userData.type === 'object' || hit.object.userData.type === 'lava'); if(firstHit) vehicleGroundY = firstHit.point.y; } vehicleA.position.y = THREE.MathUtils.lerp(vehicleA.position.y, vehicleGroundY + 0.4, 0.1); }
                
                // [MODIFIED] 차량 용암 데미지 로직 변경: 높이 비교 방식
                const vLavaHeight = getLavaHeight(vehicleA.position.x, vehicleA.position.z);
                // 차량 바퀴 높이 등을 고려하여 +0.5 정도 여유를 둠
                if (vehicleA.position.y < vLavaHeight + 0.5) {
                     const damage = 100 * delta; 
                     vehicleA.userData.health -= damage; 
                     if (playerInVehicle === vehicleA && frameCount % 60 === 0) showChat('시스템', '차량이 용암에 녹고 있습니다!'); 
                }

                if (vehicleA.userData.health <= 0) { destroyVehicle(vehicleA); vehicles.splice(i, 1); break; }
            };
            if (playerInVehicle) updateUI();
        }

        function destroyVehicle(vehicle) { if (playerInVehicle === vehicle) { toggleVehicle(vehicle, true); } createDebrisEffect(vehicle.position, vehicle.children[0].material.color, 30); scene.remove(vehicle); }

        // [FIXED] 누락된 함수 추가 (calculateDamage, hitZombie)
        function calculateDamage(weaponData, distance) {
            let damage = weaponData.damage;
            if (distance > weaponData.effectiveRange) {
                const maxRange = weaponData.maxRange || weaponData.effectiveRange + 100;
                if (distance >= maxRange) {
                    damage *= (weaponData.minDamageMultiplier || 0.1);
                } else {
                    const rangeDiff = maxRange - weaponData.effectiveRange;
                    const distDiff = distance - weaponData.effectiveRange;
                    const factor = distDiff / rangeDiff;
                    const minMult = weaponData.minDamageMultiplier || 0.1;
                    damage = damage * (1 - factor * (1 - minMult));
                }
            }
            return Math.max(0, damage);
        }

        function hitZombie(zombie, damage, attacker) {
            if (!zombie.parent || zombie.userData.health <= 0) return;
            zombie.userData.health -= damage;
            showDamage(zombie.position, damage);
            
            // 피격 효과 (빨간색 점멸)
            const originalColor = zombie.userData.originalColor;
            if (zombie.material) {
                zombie.material.color.setHex(0xff0000);
                setTimeout(() => {
                    if (zombie && zombie.userData.health > 0) {
                        zombie.material.color.copy(originalColor);
                    }
                }, 100);
            }

            if (zombie.userData.health <= 0) {
                const idx = zombies.indexOf(zombie);
                if (idx !== -1) {
                    const isPlayerKill = (!attacker || attacker === 'player');
                    handleZombieDeath(zombie, idx, isPlayerKill);
                }
            } else {
                zombie.userData.state = 'chase';
                zombie.userData.isProvoked = true;
                if (!attacker || attacker === 'player') {
                    const targetPos = playerInVehicle ? playerInVehicle.position : gameState.position;
                    zombie.userData.lastKnownPlayerPosition.copy(targetPos);
                    zombie.userData.customTarget = null;
                } else if (attacker && attacker.userData) {
                    zombie.userData.customTarget = attacker;
                }
            }
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; if (!bullet.parent) { bullets.splice(i, 1); continue; }
                const data = bullet.userData; const oldPosition = bullet.position.clone(); const weaponKey = data.weaponKey; const weaponData = WEAPON_DATABASE[weaponKey]; let speed = (weaponData ? weaponData.bulletSpeed : 300); if (data.owner === 'enemy') { speed *= 0.2; }
                
                // [FIX] 물리 엔진처럼 서브 스텝을 나누지는 않더라도, 이동 벡터 전체를 레이캐스트로 처리
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(speed * delta));
                
                if (bullet.position.y < -100) { scene.remove(bullet); bullets.splice(i, 1); continue; } 

                const travelVec = bullet.position.clone().sub(oldPosition); 
                const rayLength = travelVec.length(); 
                if (rayLength === 0) continue; 
                
                const direction = travelVec.clone().normalize();
                const rayStart = oldPosition.clone().sub(direction.multiplyScalar(0.2)); // 살짝 뒤에서 시작해 스쳐 지나가는 문제 방지
                const fullRayLength = rayLength + 0.2; 
                const bulletRay = new THREE.Ray(rayStart, direction);
                
                const dynamicCheckRadius = 50 + rayLength; 
                const dynamicCheckSq = dynamicCheckRadius * dynamicCheckRadius; 
                let bestHit = null; 
                let minHitDist = fullRayLength + 0.1; 
                
                // [FIX] 지형 충돌 터널링 방지 (Raymarching)
                // 단순히 도착점의 높이만 체크하는 것이 아니라, 이동 경로를 5미터 단위로 쪼개서 지형 통과 여부 검사
                const stepSize = 5.0; 
                const numSteps = Math.ceil(rayLength / stepSize);
                
                for (let s = 1; s <= numSteps; s++) {
                    const t = s / numSteps;
                    const posToCheck = oldPosition.clone().lerp(bullet.position, t); // 경로 상의 중간 지점
                    const tHeight = getTerrainHeight(posToCheck.x, posToCheck.z);
                    
                    if (posToCheck.y <= tHeight) {
                        // 중간 지점에서 지형과 충돌 감지
                        const dist = rayStart.distanceTo(posToCheck);
                        if (dist < minHitDist) {
                            minHitDist = dist;
                            bestHit = { type: 'ground', point: posToCheck.clone() }; // 정확한 위치는 posToCheck 근처
                            // 시각적으로 더 정확하게 지형 표면에 맞추고 싶다면 y를 tHeight로 보정
                            bestHit.point.y = tHeight; 
                        }
                        break; // 가장 먼저 부딪힌 지형만 중요하므로 루프 종료
                    }
                }

                // [FIX] 충돌 검사 대상 확장 (터널링 방지)
                // 총알이 너무 빨라 청크를 건너뛰었을 경우를 대비해, '출발지'와 '도착지' 양쪽의 주변 오브젝트를 모두 검사
                const nearbyStart = getNearbyStaticObjects(oldPosition);
                const nearbyEnd = getNearbyStaticObjects(bullet.position);
                // 중복 제거를 위해 Set 사용하거나 단순히 합침 (성능상 배열 합치고 루프 도는게 빠를 수 있음)
                // 여기선 Set으로 중복 제거하여 정확도 높임
                const potentialHitsSet = new Set([...nearbyStart, ...nearbyEnd, ...vehicles]);
                const potentialHits = Array.from(potentialHitsSet);

                if (data.owner === 'player') {
                    for (const enemy of rangedEnemies) { 
                        if (!enemy.parent) continue; 
                        if (bullet.position.distanceToSquared(enemy.position) > (dynamicCheckSq)) continue; 
                        const box = new THREE.Box3(new THREE.Vector3(-0.7, -1.25, -0.7), new THREE.Vector3(0.7, 1.25, 0.7)).translate(enemy.position); 
                        const hitPoint = bulletRay.intersectBox(box, tempVec); 
                        if (hitPoint) { 
                            const dist = rayStart.distanceTo(hitPoint); 
                            if (dist < minHitDist) { 
                                minHitDist = dist; 
                                bestHit = { type: 'enemy', obj: enemy, point: hitPoint.clone() }; 
                            } 
                        } 
                    }
                    for (const zombie of zombies) { 
                        if (!zombie.parent) continue; 
                        if (bullet.position.distanceToSquared(zombie.position) > (dynamicCheckSq)) continue; 
                        const box = new THREE.Box3(new THREE.Vector3(-0.8, -1.0, -0.8), new THREE.Vector3(0.8, 1.8, 0.8)).translate(zombie.position); 
                        const hitPoint = bulletRay.intersectBox(box, tempVec); 
                        if (hitPoint) { 
                            const dist = rayStart.distanceTo(hitPoint); 
                            if (dist < minHitDist) { 
                                minHitDist = dist; 
                                bestHit = { type: 'zombie', obj: zombie, point: hitPoint.clone() }; 
                            } 
                        } 
                    }
                    for (const boss of bosses) { 
                        if (!boss.parent) continue; 
                        if (bullet.position.distanceToSquared(boss.position) > (dynamicCheckSq)) continue; 
                        const s = boss.userData.scale; 
                        const box = new THREE.Box3(new THREE.Vector3(-0.8*s, 0, -0.8*s), new THREE.Vector3(0.8*s, 3*s, 0.8*s)).translate(boss.position); 
                        const hitPoint = bulletRay.intersectBox(box, tempVec); 
                        if (hitPoint) { 
                            const dist = rayStart.distanceTo(hitPoint); 
                            if (dist < minHitDist) { 
                                minHitDist = dist; 
                                bestHit = { type: 'boss', obj: boss, point: hitPoint.clone() }; 
                            } 
                        } 
                    }
                } else if (data.owner === 'enemy') {
                    let targetBox = null; if (playerInVehicle) { targetBox = playerInVehicle.userData.collisionBox.clone().translate(playerInVehicle.position); } else if (!isGameOver) { targetBox = new THREE.Box3(new THREE.Vector3(-0.5, -1.8, -0.5), new THREE.Vector3(0.5, 0.2, 0.5)).translate(gameState.position); }
                    if (targetBox) { 
                        const hitPoint = bulletRay.intersectBox(targetBox, tempVec); 
                        if (hitPoint) { 
                            const dist = rayStart.distanceTo(hitPoint); 
                            if (dist < minHitDist) { 
                                minHitDist = dist; 
                                bestHit = { type: 'player', point: hitPoint.clone() }; 
                            } 
                        } 
                    }
                    
                    for (const zombie of zombies) {
                        if (!zombie.parent || zombie.userData.health <= 0) continue; 
                        if (bullet.position.distanceToSquared(zombie.position) > dynamicCheckSq) continue; 
                        const box = new THREE.Box3(new THREE.Vector3(-0.6, 0, -0.6), new THREE.Vector3(0.6, 2.0, 0.6)).translate(zombie.position); 
                        const hitPoint = bulletRay.intersectBox(box, tempVec);
                        if (hitPoint) { 
                            const dist = rayStart.distanceTo(hitPoint); 
                            if (dist < minHitDist) { 
                                minHitDist = dist; 
                                bestHit = { type: 'infighting', obj: zombie, point: hitPoint.clone() }; 
                            } 
                        }
                    }
                    for (const enemy of rangedEnemies) {
                        if (!enemy.parent || enemy === data.ownerRef) continue; 
                        if (bullet.position.distanceToSquared(enemy.position) > dynamicCheckSq) continue;
                         const box = new THREE.Box3(new THREE.Vector3(-0.7, -1.25, -0.7), new THREE.Vector3(0.7, 1.25, 0.7)).translate(enemy.position);
                         const hitPoint = bulletRay.intersectBox(box, tempVec);
                         if (hitPoint) { 
                             const dist = rayStart.distanceTo(hitPoint); 
                             if (dist < minHitDist) { 
                                 minHitDist = dist; 
                                 bestHit = { type: 'enemy_infighting', obj: enemy, point: hitPoint.clone() }; 
                             } 
                         }
                    }
                }
                
                // 정적 오브젝트 충돌 검사 (potentialHits는 이제 start/end 주변 오브젝트 모두 포함)
                for (const object of potentialHits) { 
                    if (data.owner === 'player' && playerInVehicle && object === playerInVehicle) continue; 
                    if (!object.parent) continue; 
                    // [OPTIMIZATION] 거리 체크는 여전히 유효 (다만 fullRayLength 고려)
                    if (bullet.position.distanceToSquared(object.position) > dynamicCheckSq && oldPosition.distanceToSquared(object.position) > dynamicCheckSq) continue; 
                    
                    if (object.geometry) {
                        if (!object.geometry.boundingBox) object.geometry.computeBoundingBox();
                        const box = tempBox.setFromObject(object);
                        if (bulletRay.intersectsBox(box)) {
                           raycaster.set(rayStart, direction); raycaster.far = fullRayLength + 0.1; const intersections = raycaster.intersectObject(object, true);
                           if (intersections.length > 0) { const hit = intersections[0]; if (hit.distance < minHitDist) { minHitDist = hit.distance; bestHit = { type: 'object', obj: object, point: hit.point, actualObj: hit.object }; } }
                        }
                    } 
                }

                if (bestHit) {
                    const distance = bestHit.point.distanceTo(data.spawnPosition); 
                    const damage = calculateDamage(weaponData, distance);
                    
                    if (bestHit.type === 'enemy') { 
                        const enemy = bestHit.obj; enemy.userData.health -= damage; showDamage(enemy.position, damage); 
                        if (enemy.userData.health > 0) { 
                            enemy.userData.state = 'chase'; enemy.userData.customTarget = null; 
                            const targetPos = playerInVehicle ? playerInVehicle.position : gameState.position; enemy.userData.lastKnownPlayerPosition.copy(targetPos); 
                        } 
                        if (enemy.userData.health <= 0) { 
                            addMoloch(20); gainXP(30);
                            createDebrisEffect(enemy.position, enemy.material.color); scene.remove(enemy); rangedEnemies.splice(rangedEnemies.indexOf(enemy), 1);
                            showChat('시스템', '적을 처치했습니다!');
                        }
                    }
                    else if (bestHit.type === 'zombie') { 
                        hitZombie(bestHit.obj, damage, null); 
                    } 
                    else if (bestHit.type === 'player') { const pDmg = damage * 0.5; attackPlayer(pDmg); if (data.ownerRef && data.ownerRef.userData) { data.ownerRef.userData.consecutiveMisses = 0; } }
                    else if (bestHit.type === 'boss') { const boss = bestHit.obj; boss.userData.health -= damage; showDamage(boss.position, damage); }
                    
                    // 공격자가 없으면(플레이어) 플레이어 위치 갱신
                    if (bestHit.type === 'zombie' || bestHit.type === 'infighting') {
                        const zombie = bestHit.obj;
                        const targetPos = playerInVehicle ? playerInVehicle.position : gameState.position; 
                        zombie.userData.lastKnownPlayerPosition.copy(targetPos); 
                        zombie.userData.customTarget = null;
                    }

                    // [FIX] 섬광총 및 총알 삭제 로직 복구
                    if (data.weaponKey === 'FlashGun') {
                        // 섬광총은 데미지가 없지만 조명을 설치함
                        createFlare(bestHit.point);
                    } else if (bestHit.type === 'object' || bestHit.type === 'ground') {
                        // 일반 총알이 벽/바닥에 맞으면 파편 효과
                        createDebrisEffect(bestHit.point, new THREE.Color(0xAAAAAA), 3);
                    }

                    // 충돌 시 총알 제거
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
            } 
        }

        function handleAttackState(enemy, data, now, targetPos, isTargetPlayer) { 
            if(!targetPos) targetPos = data.lastKnownPlayerPosition;
            enemy.lookAt(targetPos.x, enemy.position.y, targetPos.z); 
            if (now - data.lastAttackTime > data.attackCooldown) { 
                data.lastAttackTime = now; const dist = enemy.position.distanceTo(targetPos); 
                if (dist <= data.attackRange + 1.0) { 
                    if (isTargetPlayer) { 
                        // [MODIFIED] 킬 수에 따른 난이도 스케일링 (100킬당 데미지 +10)
                        const difficultyBonus = Math.floor(gameStats.zombieKills / 100) * 10;
                        
                        // 몬스터 종류별 기본 데미지 설정
                        let baseDamage = 10; // 기본 좀비
                        if (data.isOrc) baseDamage = 15; // 오크는 좀 더 강함
                        if (data.isTroll) baseDamage = 25; // 트롤은 훨씬 강함
                        if (data.name && data.name.includes('워치프')) baseDamage = 30; // 워치프

                        const totalDamage = baseDamage + difficultyBonus;
                        attackPlayer(totalDamage); 
                    } else if (data.customTarget && data.customTarget.userData) { 
                        // [MODIFIED] 몬스터 간 전투 (Mob vs Mob)
                        const dmg = 20; 
                        const victim = data.customTarget;
                        victim.userData.health -= dmg; 
                        showDamage(victim.position, dmg, '#ffaa00'); 
                        
                        // 맞은 놈도 때린 놈을 타겟팅 (반격 메커니즘)
                        // 피해자가 타겟이 없거나 플레이어를 쫓던 중이었다면, 자신을 때린 놈으로 타겟 변경
                        if (victim.userData.health > 0 && (!victim.userData.customTarget || victim.userData.customTarget !== enemy)) {
                            // 오크나 좀비라면 반격
                            if (victim.userData.type === 'zombie' || victim.userData.type === 'enemy') {
                                victim.userData.customTarget = enemy;
                                victim.userData.state = 'chase';
                                victim.userData.isProvoked = true;
                            }
                        }

                        if (victim.userData.health <= 0) {
                            // 타겟 죽음 -> 승리 -> 타겟 초기화 (플레이어로 복귀하거나 배회)
                            data.customTarget = null;
                            data.state = 'idle';
                            // 죽은 놈 처리 (좀비면 handleZombieDeath 호출 필요하지만 여기선 약식)
                            if (victim.userData.type === 'zombie') handleZombieDeath(victim, zombies.indexOf(victim), false);
                            else if (victim.userData.type === 'enemy') { scene.remove(victim); rangedEnemies.splice(rangedEnemies.indexOf(victim), 1); }
                        }
                    } 
                } 
            } 
        }
        
        function handleZombieDeath(enemy, index, isPlayerKill = true) { 
            createDebrisEffect(enemy.position, enemy.material.color); scene.remove(enemy); zombies.splice(index, 1); 
            if (isPlayerKill) {
                if (questState.status === 1 && questState.type === 'hunt_zombie') { 
                    questState.currentAmount++; 
                    if (questState.currentAmount >= questState.targetAmount) { questState.currentAmount = questState.targetAmount; questState.status = 2; showChat('시스템', '퀘스트 목표 달성! 생존자에게 돌아가세요.'); } 
                    updateQuestUI(); 
                } 
                gameStats.zombieKills++; checkAchievements(); 
                
                // [NEW] 1000킬 달성 시 엔딩 트리거
                if (gameStats.zombieKills >= 1000 && !gameState.isEnding) {
                    startEndingSequence();
                }

                addMoloch(Math.floor(Math.random() * 5) + 1); 
                let xpGain = 10; if (enemy.userData.isTroll) xpGain = 50; if (enemy.userData.isOrc) xpGain = 20; 
                gainXP(xpGain); showChat('시스템', `✓ 적을 처치했습니다! (+${xpGain} XP)`); 
                
                if (Math.random() < 0.5) { 
                    const lootOptions = [ { type: 'item', name: '탄약', subtype: '5.56mm', amount: 10 + Math.floor(Math.random() * 10) }, { type: 'item', name: '탄약', subtype: '7.62mm', amount: 10 + Math.floor(Math.random() * 10) }, { type: 'item', name: '탄약', subtype: '.45 ACP', amount: 5 + Math.floor(Math.random() * 10) }, { type: 'item', name: '에너지드링크', amount: 1 } ]; 
                    const data = lootOptions[Math.floor(Math.random() * lootOptions.length)]; spawnItem(data, enemy.position.x, enemy.position.y, enemy.position.z); 
                } 
            }
        }

        // [NEW] 엔딩 시퀀스 함수들
        function startEndingSequence() {
            gameState.isEnding = true;
            document.exitPointerLock(); // 마우스 커서 표시
            
            showChat('시스템', '================================');
            showChat('시스템', '좀비 1,000마리 처치 달성!');
            showChat('시스템', '이 구역의 위협이 대부분 제거되었습니다.');
            
            setTimeout(() => {
                showChat('구조대', '여기는 구조 헬기 알파팀. 생존 신호를 포착했다!');
                showChat('구조대', '지금 즉시 구출하겠다. 가만히 있어라!');
            }, 1000);
            
            setTimeout(() => {
                showChat('시스템', '하늘에서 내려온 견인 광선이 당신을 감쌉니다...');
            }, 3000);

            // 승천 효과를 위한 빛기둥 생성 (선택 사항)
            const beamGeo = new THREE.CylinderGeometry(2, 2, 2000, 16);
            const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.copy(gameState.position);
            beam.position.y += 1000;
            scene.add(beam);
        }

        function showEndingScreen() {
            // 애니메이션 루프 중지 (선택 사항, 여기선 계속 돌리되 UI만 덮음)
            // isGameOver = true; // 게임 오버 상태로 만들어 조작 완전 차단
            
            document.exitPointerLock();
            const screen = document.getElementById('ending-screen');
            document.getElementById('end-kill-count').textContent = gameStats.zombieKills;
            document.getElementById('end-moloch-count').textContent = gameStats.totalMolochEarned;
            
            screen.style.display = 'flex';
        }
        
        function checkLineOfSight(fromPos, toPos) { const eyePos = fromPos.clone().add(new THREE.Vector3(0, 2.0, 0)); const targetEyePos = toPos.clone().add(new THREE.Vector3(0, 1.0, 0)); const direction = targetEyePos.clone().sub(eyePos).normalize(); const distance = eyePos.distanceTo(targetEyePos); raycaster.set(eyePos, direction); raycaster.far = distance; 
            // [OPTIMIZATION]
            const nearby = getNearbyStaticObjects(eyePos);
            const intersects = raycaster.intersectObjects([...nearby, ...structures], true); 
            const hit = intersects.find(i => i.object.geometry.type !== 'PlaneGeometry' && i.object.userData.type !== 'roof' && i.object.userData.type !== 'floor' && i.distance > 1.0 ); return !hit || hit.distance > distance - 1; }
        function attackPlayer(damage) { if (isGameOver) return; if (playerInVehicle) { showChat('시스템', '차량이 공격을 방어했습니다! (차량 내구도 감소)'); playerInVehicle.userData.health -= damage * 5; updateUI(); } else { gameState.health -= damage; showPlayerDamageEffect(); updateUI(); if (gameState.health <= 0) { gameState.health = 0; handleGameOver(); } } }
        function updateItems(delta) { 
            const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position;
            items.forEach(item => { if (item.position.distanceToSquared(playerPos) > ACTIVE_RADIUS_SQ) { item.visible = false; return; } item.visible = true; if (item.userData.type !== 'weapon') { item.rotation.y += 0.02; } if (item.userData.isGrounded) return; raycaster.far = 500; raycaster.set(item.position.clone().add(new THREE.Vector3(0, 1, 0)), new THREE.Vector3(0, -1, 0)); const itemIntersects = raycaster.intersectObjects(objects, true); let targetY = item.position.y; if (itemIntersects.length > 0) { const firstHit = itemIntersects.find(hit => hit.object.geometry.type === 'PlaneGeometry' || hit.object.userData.type === 'roof' || hit.object.userData.type === 'floor' || hit.object.userData.type === 'object'); if(firstHit) { targetY = firstHit.point.y + 0.5; } } if (Math.abs(item.position.y - targetY) < 0.05) { item.position.y = targetY; item.userData.isGrounded = true; } else { item.position.y = THREE.MathUtils.lerp(item.position.y, targetY, 0.1); } item.userData.baseY = item.position.y; });
        }
        
        function animate() {
            if (isGameOver) return; requestAnimationFrame(animate); 
            const now = Date.now(); const delta = clock.getDelta(); frameCount++;
            
            updateWorldState(delta); updatePlayer(delta); updateBullets(delta); updateZombies(delta);
            
            rangedEnemies.forEach((enemy, index) => {
                if (enemy.userData.health <= 0) return;
                const distSq = enemy.position.distanceToSquared(gameState.position);
                
                // [OPTIMIZATION] AI 쓰로틀링 (원거리 적)
                if (distSq > 2500 && (frameCount + index) % 4 !== 0) return;

                if (distSq > ACTIVE_RADIUS_SQ) { enemy.visible = false; return; }
                enemy.visible = true;
                if (distSq > 10000 && frameCount % 2 !== 0) return;

                const data = enemy.userData; const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position;
                
                // [FIX] 원거리 적 스폰 보호 적용
                // 아직 안전 구역(hasLeftSafeZone === 0)이고, 적이 화난 상태('chase')가 아니면 무시
                // 플레이어가 총을 쏘거나 때리면 performPunch에서 state가 'chase'로 바뀌므로 그때부턴 반격함
                const isSafeZone = (hasLeftSafeZone === 0);
                if (isSafeZone && data.state !== 'chase') return;

                const groundY = getTerrainHeight(enemy.position.x, enemy.position.z);
                if (data.isJumping) { enemy.position.y += data.velocityY; data.velocityY -= 0.03; if (enemy.position.y <= groundY + 1.25) { enemy.position.y = groundY + 1.25; data.isJumping = false; data.velocityY = 0; } } else { enemy.position.y = groundY + 1.25; }

                if (now - data.lastMoveTime > 100) {
                    enemy.lookAt(playerPos.x, enemy.position.y, playerPos.z); const dist = Math.sqrt(distSq);
                    if (dist <= data.attackRange) { if (now - data.lastShotTime > data.fireRate) { data.lastShotTime = now; rangedEnemyShoot(enemy); } } else if (dist <= data.detectionRange) { const dir = playerPos.clone().sub(enemy.position).normalize(); dir.y = 0; enemy.position.add(dir.multiplyScalar(data.speed * delta * 0.5)); }
                    data.lastMoveTime = now;
                }
            });

            updateVehicles(delta); updateItems(delta); updateNPCs(delta); updateFlares(delta); updateDebris(delta);
            updateBosses(delta, now, gameState.position); updateHazardZones(now);
            updateInteraction();
            
            const currentChunkX = Math.round(gameState.position.x / CHUNK_SIZE);
            const currentChunkZ = Math.round(gameState.position.z / CHUNK_SIZE);
            const newChunkKey = `${currentChunkX},${currentChunkZ}`;
            if (newChunkKey !== currentPlayerChunkKey) { currentPlayerChunkKey = newChunkKey; updateWorldChunks(); }

            renderer.render(scene, camera);
        }
        
        function updateWorldState(delta) {
            gameTime += delta * 0.5;
            const timeOfDay = (gameTime % GAME_DAY_DURATION) / GAME_DAY_DURATION; const totalMinutes = Math.floor(timeOfDay * 24 * 60); const hours = Math.floor(totalMinutes / 60); const minutes = totalMinutes % 60; document.getElementById('time-display').textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            const theta = (timeOfDay - 0.25) * Math.PI * 2; const sunHeight = Math.sin(theta); const cosTheta = Math.cos(theta); const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position; const lightOffset = 100;
            sun.position.x = playerPos.x + cosTheta * lightOffset; sun.position.y = playerPos.y + sunHeight * lightOffset; sun.position.z = playerPos.z; sun.target.position.copy(playerPos); sun.target.updateMatrixWorld();
            const visualDist = 2000; sunMesh.position.set(playerPos.x + cosTheta * visualDist, playerPos.y + sunHeight * visualDist, playerPos.z); moonMesh.position.set(playerPos.x - cosTheta * visualDist, playerPos.y - sunHeight * visualDist, playerPos.z); moonMesh.rotation.y += delta * 0.05; sunMesh.lookAt(playerPos); moonMesh.lookAt(playerPos);
            
            const lightIntensity = Math.max(0.05, sunHeight); sun.intensity = lightIntensity * 0.8 + 0.1; 
            let ambientBase = Math.max(0.1, lightIntensity * 0.4);
            const nightVisionBonus = gameState.stats.perception * 0.005; 
            scene.ambientLight.intensity = Math.min(1.0, ambientBase + nightVisionBonus); 
            
            const dayColor = new THREE.Color(0x87CEEB); const sunsetColor = new THREE.Color(0xfd5e53); const nightColor = new THREE.Color(0x050515); const dayFog = new THREE.Color(0x87CEEB); const sunsetFog = new THREE.Color(0xfd5e53); const nightFog = new THREE.Color(0x050515);
            let currentColor, currentFog;
            if (sunHeight < 0.1 && sunHeight > -0.1) { const t = (sunHeight + 0.1) / 0.2; if (timeOfDay < 0.5) { currentColor = nightColor.clone().lerp(dayColor, t); currentFog = nightFog.clone().lerp(dayFog, t); currentColor.lerp(sunsetColor, 0.3 * (1 - Math.abs(t - 0.5) * 2)); } else { currentColor = dayColor.clone().lerp(nightColor, 1-t); currentFog = dayFog.clone().lerp(nightFog, 1-t); currentColor.lerp(sunsetColor, 0.3 * (1 - Math.abs(t - 0.5) * 2)); } } else if (sunHeight >= 0.1) { currentColor = dayColor; currentFog = dayFog; } else { currentColor = nightColor; currentFog = nightFog; }
            scene.background.copy(currentColor); scene.fog.color.copy(currentFog);
            const oldIsNight = isNight; isNight = sunHeight < 0; if (isNight && !oldIsNight) showChat('시스템', '밤이 되었습니다. 주변이 위험해집니다...'); else if (!isNight && oldIsNight) showChat('시스템', '아침이 밝았습니다.');
            if (isNight && hasLeftSafeZone === 1 && !gameState.hordeActive && (gameTime - gameState.lastHordeTime > gameState.hordeCooldown)) { startHordeEvent(); }
            if (hasLeftSafeZone === 0) { const playerPos = playerInVehicle ? playerInVehicle.position : gameState.position; const distFromSpawn = playerPos.length(); if (distFromSpawn > SAFE_ZONE_RADIUS) { hasLeftSafeZone = 1; showChat('시스템', '⚠️ 안전 구역을 벗어났습니다! 이제부터 적들이 당신을 인식합니다. (되돌아와도 소용없음)'); } }
        }
        
        function startHordeEvent() {
            gameState.hordeActive = true;
            const warningEl = document.getElementById('horde-warning');
            warningEl.style.opacity = '1';
            showChat('시스템', '🚨 피의 밤이 시작되었습니다! 좀비들이 몰려옵니다!');
            
            const playerPos = gameState.position;
            for(let i=0; i<15; i++) {
                const angle = Math.random() * Math.PI * 2; const dist = 30 + Math.random() * 20; const x = playerPos.x + Math.cos(angle) * dist; const z = playerPos.z + Math.sin(angle) * dist; const y = getTerrainHeight(x, z); createZombie(x, z, 300, y);
                const zomb = zombies[zombies.length-1]; zomb.userData.state = 'chase'; zomb.userData.lastKnownPlayerPosition.copy(playerPos);
            }

            setTimeout(() => {
                warningEl.style.opacity = '0'; gameState.hordeActive = false; gameState.lastHordeTime = gameTime; showChat('시스템', '좀비 떼가 물러갔습니다...');
            }, 30000); 
        }

        // Helper functions
        function createDebrisEffect(pos, color, count=5) { for(let i=0; i<count; i++) { const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1); const mat = new THREE.MeshBasicMaterial({color: color}); const p = new THREE.Mesh(geo, mat); p.position.copy(pos); p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*10, Math.random()*10, (Math.random()-0.5)*10); p.userData.life = 1.0; scene.add(p); debrisParticles.push(p); } }
        function updateDebris(delta) { for(let i=debrisParticles.length-1; i>=0; i--) { const p = debrisParticles[i]; p.userData.life -= delta; p.userData.velocity.y -= 20 * delta; p.position.add(p.userData.velocity.clone().multiplyScalar(delta)); if(p.userData.life <= 0 || p.position.y < -50) { scene.remove(p); debrisParticles.splice(i, 1); } } }
        
        // [FIX] 데미지 텍스트가 겹치지 않도록 위치에 약간의 랜덤 오프셋 추가
        function showDamage(pos, amount, color='#ff0000') { 
            const el = document.createElement('div'); el.className = 'damage-text'; el.textContent = Math.floor(amount); el.style.color = color; document.body.appendChild(el); 
            
            // 위치 랜덤화 (-0.5 ~ +0.5)
            const offsetX = (Math.random() - 0.5) * 0.5;
            const offsetY = (Math.random() - 0.5) * 0.5;
            const offsetZ = (Math.random() - 0.5) * 0.5;
            
            const vec = pos.clone().add(new THREE.Vector3(offsetX, 2.0 + offsetY, offsetZ)); 
            
            vec.project(camera); const x = (vec.x * .5 + .5) * window.innerWidth; const y = (-(vec.y * .5) + .5) * window.innerHeight; el.style.left = `${x}px`; el.style.top = `${y}px`;
            setTimeout(() => { if(document.body.contains(el)) document.body.removeChild(el); }, 1000); 
        }
        function showPlayerDamageEffect() { const el = document.getElementById('player-hit-overlay'); el.style.opacity = '1'; setTimeout(() => el.style.opacity = '0', 300); }
        function showLavaDamageEffect() { const el = document.getElementById('lava-damage-overlay'); el.style.opacity = '1'; setTimeout(() => el.style.opacity = '0', 300); }
        function handleGameOver() { if (isGameOver) return; isGameOver = true; document.exitPointerLock(); document.getElementById('game-over-screen').style.display = 'flex'; }
        
        function isPositionInView(pos) {
            camera.updateMatrixWorld(); camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            const frustum = new THREE.Frustum(); frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
            return frustum.containsPoint(pos);
        }

        init();
    </script>
</body>
</html>
